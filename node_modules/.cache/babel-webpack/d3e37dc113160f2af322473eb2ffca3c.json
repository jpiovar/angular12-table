{"ast":null,"code":"import _createForOfIteratorHelper from \"C:/projects/custom/angular11_12_table/node_modules/@babel/runtime/helpers/esm/createForOfIteratorHelper\";\nimport _toConsumableArray from \"C:/projects/custom/angular11_12_table/node_modules/@babel/runtime/helpers/esm/toConsumableArray\";\nimport _inherits from \"C:/projects/custom/angular11_12_table/node_modules/@babel/runtime/helpers/esm/inherits\";\nimport _createSuper from \"C:/projects/custom/angular11_12_table/node_modules/@babel/runtime/helpers/esm/createSuper\";\nimport _slicedToArray from \"C:/projects/custom/angular11_12_table/node_modules/@babel/runtime/helpers/esm/slicedToArray\";\nimport _classCallCheck from \"C:/projects/custom/angular11_12_table/node_modules/@babel/runtime/helpers/esm/classCallCheck\";\nimport _createClass from \"C:/projects/custom/angular11_12_table/node_modules/@babel/runtime/helpers/esm/createClass\";\nimport _regeneratorRuntime from \"C:/projects/custom/angular11_12_table/node_modules/@babel/runtime/regenerator\";\n\n/**\n * @license Angular v12.1.4\n * (c) 2010-2021 Google LLC. https://angular.io/\n * License: MIT\n */\nimport { getDebugNode, RendererFactory2, ɵstringify, ɵReflectionCapabilities, Directive, Component, Pipe, NgModule, ɵgetInjectableDef, resolveForwardRef, ɵNG_COMP_DEF, ɵRender3NgModuleRef, ApplicationInitStatus, LOCALE_ID, ɵDEFAULT_LOCALE_ID, ɵsetLocaleId, ɵRender3ComponentFactory, ɵcompileComponent, ɵNG_DIR_DEF, ɵcompileDirective, ɵNG_PIPE_DEF, ɵcompilePipe, ɵNG_MOD_DEF, ɵtransitiveScopesFor, ɵpatchComponentDefWithScope, ɵNG_INJ_DEF, ɵcompileNgModuleDefs, NgZone, Compiler, COMPILER_OPTIONS, ɵNgModuleFactory, ModuleWithComponentFactories, InjectionToken, Injector, InjectFlags, ɵresetCompiledComponents, ɵflushModuleScopingQueueAsMuchAsPossible, Injectable, ɵclearOverrides, ɵoverrideComponentView, ɵINJECTOR_SCOPE, Optional, SkipSelf, ɵoverrideProvider, ɵivyEnabled } from '@angular/core';\nimport { __awaiter } from 'tslib';\nimport { ResourceLoader } from '@angular/compiler';\n/**\n * @license\n * Copyright Google LLC All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.io/license\n */\n\n/**\n * Wraps a test function in an asynchronous test zone. The test will automatically\n * complete when all asynchronous calls within this zone are done. Can be used\n * to wrap an {@link inject} call.\n *\n * Example:\n *\n * ```\n * it('...', waitForAsync(inject([AClass], (object) => {\n *   object.doSomething.then(() => {\n *     expect(...);\n *   })\n * });\n * ```\n *\n * @publicApi\n */\n\nimport * as ɵngcc0 from '@angular/core';\n\nfunction waitForAsync(fn) {\n  var _Zone = typeof Zone !== 'undefined' ? Zone : null;\n\n  if (!_Zone) {\n    return function () {\n      return Promise.reject('Zone is needed for the waitForAsync() test helper but could not be found. ' + 'Please make sure that your environment includes zone.js');\n    };\n  }\n\n  var asyncTest = _Zone && _Zone[_Zone.__symbol__('asyncTest')];\n\n  if (typeof asyncTest === 'function') {\n    return asyncTest(fn);\n  }\n\n  return function () {\n    return Promise.reject('zone-testing.js is needed for the async() test helper but could not be found. ' + 'Please make sure that your environment includes zone.js/testing');\n  };\n}\n/**\n * @deprecated use `waitForAsync()`, (expected removal in v12)\n * @see {@link waitForAsync}\n * @publicApi\n * */\n\n\nfunction async(fn) {\n  return waitForAsync(fn);\n}\n/**\n * @license\n * Copyright Google LLC All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.io/license\n */\n\n/**\n * Fixture for debugging and testing a component.\n *\n * @publicApi\n */\n\n\nvar ComponentFixture = /*#__PURE__*/function () {\n  function ComponentFixture(componentRef, ngZone, _autoDetect) {\n    var _this = this;\n\n    _classCallCheck(this, ComponentFixture);\n\n    this.componentRef = componentRef;\n    this.ngZone = ngZone;\n    this._autoDetect = _autoDetect;\n    this._isStable = true;\n    this._isDestroyed = false;\n    this._resolve = null;\n    this._promise = null;\n    this._onUnstableSubscription = null;\n    this._onStableSubscription = null;\n    this._onMicrotaskEmptySubscription = null;\n    this._onErrorSubscription = null;\n    this.changeDetectorRef = componentRef.changeDetectorRef;\n    this.elementRef = componentRef.location;\n    this.debugElement = getDebugNode(this.elementRef.nativeElement);\n    this.componentInstance = componentRef.instance;\n    this.nativeElement = this.elementRef.nativeElement;\n    this.componentRef = componentRef;\n    this.ngZone = ngZone;\n\n    if (ngZone) {\n      // Create subscriptions outside the NgZone so that the callbacks run oustide\n      // of NgZone.\n      ngZone.runOutsideAngular(function () {\n        _this._onUnstableSubscription = ngZone.onUnstable.subscribe({\n          next: function next() {\n            _this._isStable = false;\n          }\n        });\n        _this._onMicrotaskEmptySubscription = ngZone.onMicrotaskEmpty.subscribe({\n          next: function next() {\n            if (_this._autoDetect) {\n              // Do a change detection run with checkNoChanges set to true to check\n              // there are no changes on the second run.\n              _this.detectChanges(true);\n            }\n          }\n        });\n        _this._onStableSubscription = ngZone.onStable.subscribe({\n          next: function next() {\n            _this._isStable = true; // Check whether there is a pending whenStable() completer to resolve.\n\n            if (_this._promise !== null) {\n              // If so check whether there are no pending macrotasks before resolving.\n              // Do this check in the next tick so that ngZone gets a chance to update the state of\n              // pending macrotasks.\n              scheduleMicroTask(function () {\n                if (!ngZone.hasPendingMacrotasks) {\n                  if (_this._promise !== null) {\n                    _this._resolve(true);\n\n                    _this._resolve = null;\n                    _this._promise = null;\n                  }\n                }\n              });\n            }\n          }\n        });\n        _this._onErrorSubscription = ngZone.onError.subscribe({\n          next: function next(error) {\n            throw error;\n          }\n        });\n      });\n    }\n  }\n\n  _createClass(ComponentFixture, [{\n    key: \"_tick\",\n    value: function _tick(checkNoChanges) {\n      this.changeDetectorRef.detectChanges();\n\n      if (checkNoChanges) {\n        this.checkNoChanges();\n      }\n    }\n    /**\n     * Trigger a change detection cycle for the component.\n     */\n\n  }, {\n    key: \"detectChanges\",\n    value: function detectChanges() {\n      var _this2 = this;\n\n      var checkNoChanges = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : true;\n\n      if (this.ngZone != null) {\n        // Run the change detection inside the NgZone so that any async tasks as part of the change\n        // detection are captured by the zone and can be waited for in isStable.\n        this.ngZone.run(function () {\n          _this2._tick(checkNoChanges);\n        });\n      } else {\n        // Running without zone. Just do the change detection.\n        this._tick(checkNoChanges);\n      }\n    }\n    /**\n     * Do a change detection run to make sure there were no changes.\n     */\n\n  }, {\n    key: \"checkNoChanges\",\n    value: function checkNoChanges() {\n      this.changeDetectorRef.checkNoChanges();\n    }\n    /**\n     * Set whether the fixture should autodetect changes.\n     *\n     * Also runs detectChanges once so that any existing change is detected.\n     */\n\n  }, {\n    key: \"autoDetectChanges\",\n    value: function autoDetectChanges() {\n      var autoDetect = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : true;\n\n      if (this.ngZone == null) {\n        throw new Error('Cannot call autoDetectChanges when ComponentFixtureNoNgZone is set');\n      }\n\n      this._autoDetect = autoDetect;\n      this.detectChanges();\n    }\n    /**\n     * Return whether the fixture is currently stable or has async tasks that have not been completed\n     * yet.\n     */\n\n  }, {\n    key: \"isStable\",\n    value: function isStable() {\n      return this._isStable && !this.ngZone.hasPendingMacrotasks;\n    }\n    /**\n     * Get a promise that resolves when the fixture is stable.\n     *\n     * This can be used to resume testing after events have triggered asynchronous activity or\n     * asynchronous change detection.\n     */\n\n  }, {\n    key: \"whenStable\",\n    value: function whenStable() {\n      var _this3 = this;\n\n      if (this.isStable()) {\n        return Promise.resolve(false);\n      } else if (this._promise !== null) {\n        return this._promise;\n      } else {\n        this._promise = new Promise(function (res) {\n          _this3._resolve = res;\n        });\n        return this._promise;\n      }\n    }\n  }, {\n    key: \"_getRenderer\",\n    value: function _getRenderer() {\n      if (this._renderer === undefined) {\n        this._renderer = this.componentRef.injector.get(RendererFactory2, null);\n      }\n\n      return this._renderer;\n    }\n    /**\n     * Get a promise that resolves when the ui state is stable following animations.\n     */\n\n  }, {\n    key: \"whenRenderingDone\",\n    value: function whenRenderingDone() {\n      var renderer = this._getRenderer();\n\n      if (renderer && renderer.whenRenderingDone) {\n        return renderer.whenRenderingDone();\n      }\n\n      return this.whenStable();\n    }\n    /**\n     * Trigger component destruction.\n     */\n\n  }, {\n    key: \"destroy\",\n    value: function destroy() {\n      if (!this._isDestroyed) {\n        this.componentRef.destroy();\n\n        if (this._onUnstableSubscription != null) {\n          this._onUnstableSubscription.unsubscribe();\n\n          this._onUnstableSubscription = null;\n        }\n\n        if (this._onStableSubscription != null) {\n          this._onStableSubscription.unsubscribe();\n\n          this._onStableSubscription = null;\n        }\n\n        if (this._onMicrotaskEmptySubscription != null) {\n          this._onMicrotaskEmptySubscription.unsubscribe();\n\n          this._onMicrotaskEmptySubscription = null;\n        }\n\n        if (this._onErrorSubscription != null) {\n          this._onErrorSubscription.unsubscribe();\n\n          this._onErrorSubscription = null;\n        }\n\n        this._isDestroyed = true;\n      }\n    }\n  }]);\n\n  return ComponentFixture;\n}();\n\nfunction scheduleMicroTask(fn) {\n  Zone.current.scheduleMicroTask('scheduleMicrotask', fn);\n}\n/**\n * @license\n * Copyright Google LLC All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.io/license\n */\n\n\nvar _Zone = typeof Zone !== 'undefined' ? Zone : null;\n\nvar fakeAsyncTestModule = _Zone && _Zone[_Zone.__symbol__('fakeAsyncTest')];\n\nvar fakeAsyncTestModuleNotLoadedErrorMessage = \"zone-testing.js is needed for the fakeAsync() test helper but could not be found.\\n        Please make sure that your environment includes zone.js/testing\";\n/**\n * Clears out the shared fake async zone for a test.\n * To be called in a global `beforeEach`.\n *\n * @publicApi\n */\n\nfunction resetFakeAsyncZone() {\n  if (fakeAsyncTestModule) {\n    return fakeAsyncTestModule.resetFakeAsyncZone();\n  }\n\n  throw new Error(fakeAsyncTestModuleNotLoadedErrorMessage);\n}\n/**\n * Wraps a function to be executed in the `fakeAsync` zone:\n * - Microtasks are manually executed by calling `flushMicrotasks()`.\n * - Timers are synchronous; `tick()` simulates the asynchronous passage of time.\n *\n * If there are any pending timers at the end of the function, an exception is thrown.\n *\n * Can be used to wrap `inject()` calls.\n *\n * @param fn The function that you want to wrap in the `fakeAysnc` zone.\n *\n * @usageNotes\n * ### Example\n *\n * {@example core/testing/ts/fake_async.ts region='basic'}\n *\n *\n * @returns The function wrapped to be executed in the `fakeAsync` zone.\n * Any arguments passed when calling this returned function will be passed through to the `fn`\n * function in the parameters when it is called.\n *\n * @publicApi\n */\n\n\nfunction fakeAsync(fn) {\n  if (fakeAsyncTestModule) {\n    return fakeAsyncTestModule.fakeAsync(fn);\n  }\n\n  throw new Error(fakeAsyncTestModuleNotLoadedErrorMessage);\n}\n/**\n * Simulates the asynchronous passage of time for the timers in the `fakeAsync` zone.\n *\n * The microtasks queue is drained at the very start of this function and after any timer callback\n * has been executed.\n *\n * @param millis The number of milliseconds to advance the virtual timer.\n * @param tickOptions The options to pass to the `tick()` function.\n *\n * @usageNotes\n *\n * The `tick()` option is a flag called `processNewMacroTasksSynchronously`,\n * which determines whether or not to invoke new macroTasks.\n *\n * If you provide a `tickOptions` object, but do not specify a\n * `processNewMacroTasksSynchronously` property (`tick(100, {})`),\n * then `processNewMacroTasksSynchronously` defaults to true.\n *\n * If you omit the `tickOptions` parameter (`tick(100))`), then\n * `tickOptions` defaults to `{processNewMacroTasksSynchronously: true}`.\n *\n * ### Example\n *\n * {@example core/testing/ts/fake_async.ts region='basic'}\n *\n * The following example includes a nested timeout (new macroTask), and\n * the `tickOptions` parameter is allowed to default. In this case,\n * `processNewMacroTasksSynchronously` defaults to true, and the nested\n * function is executed on each tick.\n *\n * ```\n * it ('test with nested setTimeout', fakeAsync(() => {\n *   let nestedTimeoutInvoked = false;\n *   function funcWithNestedTimeout() {\n *     setTimeout(() => {\n *       nestedTimeoutInvoked = true;\n *     });\n *   };\n *   setTimeout(funcWithNestedTimeout);\n *   tick();\n *   expect(nestedTimeoutInvoked).toBe(true);\n * }));\n * ```\n *\n * In the following case, `processNewMacroTasksSynchronously` is explicitly\n * set to false, so the nested timeout function is not invoked.\n *\n * ```\n * it ('test with nested setTimeout', fakeAsync(() => {\n *   let nestedTimeoutInvoked = false;\n *   function funcWithNestedTimeout() {\n *     setTimeout(() => {\n *       nestedTimeoutInvoked = true;\n *     });\n *   };\n *   setTimeout(funcWithNestedTimeout);\n *   tick(0, {processNewMacroTasksSynchronously: false});\n *   expect(nestedTimeoutInvoked).toBe(false);\n * }));\n * ```\n *\n *\n * @publicApi\n */\n\n\nfunction tick() {\n  var millis = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : 0;\n  var tickOptions = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {\n    processNewMacroTasksSynchronously: true\n  };\n\n  if (fakeAsyncTestModule) {\n    return fakeAsyncTestModule.tick(millis, tickOptions);\n  }\n\n  throw new Error(fakeAsyncTestModuleNotLoadedErrorMessage);\n}\n/**\n * Simulates the asynchronous passage of time for the timers in the `fakeAsync` zone by\n * draining the macrotask queue until it is empty.\n *\n * @param maxTurns The maximum number of times the scheduler attempts to clear its queue before\n *     throwing an error.\n * @returns The simulated time elapsed, in milliseconds.\n *\n * @publicApi\n */\n\n\nfunction flush(maxTurns) {\n  if (fakeAsyncTestModule) {\n    return fakeAsyncTestModule.flush(maxTurns);\n  }\n\n  throw new Error(fakeAsyncTestModuleNotLoadedErrorMessage);\n}\n/**\n * Discard all remaining periodic tasks.\n *\n * @publicApi\n */\n\n\nfunction discardPeriodicTasks() {\n  if (fakeAsyncTestModule) {\n    return fakeAsyncTestModule.discardPeriodicTasks();\n  }\n\n  throw new Error(fakeAsyncTestModuleNotLoadedErrorMessage);\n}\n/**\n * Flush any pending microtasks.\n *\n * @publicApi\n */\n\n\nfunction flushMicrotasks() {\n  if (fakeAsyncTestModule) {\n    return fakeAsyncTestModule.flushMicrotasks();\n  }\n\n  throw new Error(fakeAsyncTestModuleNotLoadedErrorMessage);\n}\n/**\n * @license\n * Copyright Google LLC All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.io/license\n */\n\n/**\n * Used to resolve resource URLs on `@Component` when used with JIT compilation.\n *\n * Example:\n * ```\n * @Component({\n *   selector: 'my-comp',\n *   templateUrl: 'my-comp.html', // This requires asynchronous resolution\n * })\n * class MyComponent{\n * }\n *\n * // Calling `renderComponent` will fail because `renderComponent` is a synchronous process\n * // and `MyComponent`'s `@Component.templateUrl` needs to be resolved asynchronously.\n *\n * // Calling `resolveComponentResources()` will resolve `@Component.templateUrl` into\n * // `@Component.template`, which allows `renderComponent` to proceed in a synchronous manner.\n *\n * // Use browser's `fetch()` function as the default resource resolution strategy.\n * resolveComponentResources(fetch).then(() => {\n *   // After resolution all URLs have been converted into `template` strings.\n *   renderComponent(MyComponent);\n * });\n *\n * ```\n *\n * NOTE: In AOT the resolution happens during compilation, and so there should be no need\n * to call this method outside JIT mode.\n *\n * @param resourceResolver a function which is responsible for returning a `Promise` to the\n * contents of the resolved URL. Browser's `fetch()` method is a good default implementation.\n */\n\n\nfunction resolveComponentResources(resourceResolver) {\n  // Store all promises which are fetching the resources.\n  var componentResolved = []; // Cache so that we don't fetch the same resource more than once.\n\n  var urlMap = new Map();\n\n  function cachedResourceResolve(url) {\n    var promise = urlMap.get(url);\n\n    if (!promise) {\n      var resp = resourceResolver(url);\n      urlMap.set(url, promise = resp.then(unwrapResponse));\n    }\n\n    return promise;\n  }\n\n  componentResourceResolutionQueue.forEach(function (component, type) {\n    var promises = [];\n\n    if (component.templateUrl) {\n      promises.push(cachedResourceResolve(component.templateUrl).then(function (template) {\n        component.template = template;\n      }));\n    }\n\n    var styleUrls = component.styleUrls;\n    var styles = component.styles || (component.styles = []);\n    var styleOffset = component.styles.length;\n    styleUrls && styleUrls.forEach(function (styleUrl, index) {\n      styles.push(''); // pre-allocate array.\n\n      promises.push(cachedResourceResolve(styleUrl).then(function (style) {\n        styles[styleOffset + index] = style;\n        styleUrls.splice(styleUrls.indexOf(styleUrl), 1);\n\n        if (styleUrls.length == 0) {\n          component.styleUrls = undefined;\n        }\n      }));\n    });\n    var fullyResolved = Promise.all(promises).then(function () {\n      return componentDefResolved(type);\n    });\n    componentResolved.push(fullyResolved);\n  });\n  clearResolutionOfComponentResourcesQueue();\n  return Promise.all(componentResolved).then(function () {\n    return undefined;\n  });\n}\n\nvar componentResourceResolutionQueue = new Map(); // Track when existing ɵcmp for a Type is waiting on resources.\n\nvar componentDefPendingResolution = new Set();\n\nfunction maybeQueueResolutionOfComponentResources(type, metadata) {\n  if (componentNeedsResolution(metadata)) {\n    componentResourceResolutionQueue.set(type, metadata);\n    componentDefPendingResolution.add(type);\n  }\n}\n\nfunction isComponentDefPendingResolution(type) {\n  return componentDefPendingResolution.has(type);\n}\n\nfunction componentNeedsResolution(component) {\n  return !!(component.templateUrl && !component.hasOwnProperty('template') || component.styleUrls && component.styleUrls.length);\n}\n\nfunction clearResolutionOfComponentResourcesQueue() {\n  var old = componentResourceResolutionQueue;\n  componentResourceResolutionQueue = new Map();\n  return old;\n}\n\nfunction _restoreComponentResolutionQueue(queue) {\n  componentDefPendingResolution.clear();\n  queue.forEach(function (_, type) {\n    return componentDefPendingResolution.add(type);\n  });\n  componentResourceResolutionQueue = queue;\n}\n\nfunction isComponentResourceResolutionQueueEmpty() {\n  return componentResourceResolutionQueue.size === 0;\n}\n\nfunction unwrapResponse(response) {\n  return typeof response == 'string' ? response : response.text();\n}\n\nfunction componentDefResolved(type) {\n  componentDefPendingResolution.delete(type);\n}\n/**\n * @license\n * Copyright Google LLC All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.io/license\n */\n\n\nvar _nextReferenceId = 0;\n\nvar MetadataOverrider = /*#__PURE__*/function () {\n  function MetadataOverrider() {\n    _classCallCheck(this, MetadataOverrider);\n\n    this._references = new Map();\n  }\n  /**\n   * Creates a new instance for the given metadata class\n   * based on an old instance and overrides.\n   */\n\n\n  _createClass(MetadataOverrider, [{\n    key: \"overrideMetadata\",\n    value: function overrideMetadata(metadataClass, oldMetadata, override) {\n      var props = {};\n\n      if (oldMetadata) {\n        _valueProps(oldMetadata).forEach(function (prop) {\n          return props[prop] = oldMetadata[prop];\n        });\n      }\n\n      if (override.set) {\n        if (override.remove || override.add) {\n          throw new Error(\"Cannot set and add/remove \".concat(ɵstringify(metadataClass), \" at the same time!\"));\n        }\n\n        setMetadata(props, override.set);\n      }\n\n      if (override.remove) {\n        removeMetadata(props, override.remove, this._references);\n      }\n\n      if (override.add) {\n        addMetadata(props, override.add);\n      }\n\n      return new metadataClass(props);\n    }\n  }]);\n\n  return MetadataOverrider;\n}();\n\nfunction removeMetadata(metadata, remove, references) {\n  var removeObjects = new Set();\n\n  var _loop = function _loop(prop) {\n    var removeValue = remove[prop];\n\n    if (Array.isArray(removeValue)) {\n      removeValue.forEach(function (value) {\n        removeObjects.add(_propHashKey(prop, value, references));\n      });\n    } else {\n      removeObjects.add(_propHashKey(prop, removeValue, references));\n    }\n  };\n\n  for (var prop in remove) {\n    _loop(prop);\n  }\n\n  var _loop2 = function _loop2(_prop) {\n    var propValue = metadata[_prop];\n\n    if (Array.isArray(propValue)) {\n      metadata[_prop] = propValue.filter(function (value) {\n        return !removeObjects.has(_propHashKey(_prop, value, references));\n      });\n    } else {\n      if (removeObjects.has(_propHashKey(_prop, propValue, references))) {\n        metadata[_prop] = undefined;\n      }\n    }\n  };\n\n  for (var _prop in metadata) {\n    _loop2(_prop);\n  }\n}\n\nfunction addMetadata(metadata, add) {\n  for (var prop in add) {\n    var addValue = add[prop];\n    var propValue = metadata[prop];\n\n    if (propValue != null && Array.isArray(propValue)) {\n      metadata[prop] = propValue.concat(addValue);\n    } else {\n      metadata[prop] = addValue;\n    }\n  }\n}\n\nfunction setMetadata(metadata, set) {\n  for (var prop in set) {\n    metadata[prop] = set[prop];\n  }\n}\n\nfunction _propHashKey(propName, propValue, references) {\n  var replacer = function replacer(key, value) {\n    if (typeof value === 'function') {\n      value = _serializeReference(value, references);\n    }\n\n    return value;\n  };\n\n  return \"\".concat(propName, \":\").concat(JSON.stringify(propValue, replacer));\n}\n\nfunction _serializeReference(ref, references) {\n  var id = references.get(ref);\n\n  if (!id) {\n    id = \"\".concat(ɵstringify(ref)).concat(_nextReferenceId++);\n    references.set(ref, id);\n  }\n\n  return id;\n}\n\nfunction _valueProps(obj) {\n  var props = []; // regular public props\n\n  Object.keys(obj).forEach(function (prop) {\n    if (!prop.startsWith('_')) {\n      props.push(prop);\n    }\n  }); // getters\n\n  var proto = obj;\n\n  while (proto = Object.getPrototypeOf(proto)) {\n    Object.keys(proto).forEach(function (protoProp) {\n      var desc = Object.getOwnPropertyDescriptor(proto, protoProp);\n\n      if (!protoProp.startsWith('_') && desc && 'get' in desc) {\n        props.push(protoProp);\n      }\n    });\n  }\n\n  return props;\n}\n/**\n * @license\n * Copyright Google LLC All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.io/license\n */\n\n\nvar reflection = new ɵReflectionCapabilities();\n/**\n * Allows to override ivy metadata for tests (via the `TestBed`).\n */\n\nvar OverrideResolver = /*#__PURE__*/function () {\n  function OverrideResolver() {\n    _classCallCheck(this, OverrideResolver);\n\n    this.overrides = new Map();\n    this.resolved = new Map();\n  }\n\n  _createClass(OverrideResolver, [{\n    key: \"addOverride\",\n    value: function addOverride(type, override) {\n      var overrides = this.overrides.get(type) || [];\n      overrides.push(override);\n      this.overrides.set(type, overrides);\n      this.resolved.delete(type);\n    }\n  }, {\n    key: \"setOverrides\",\n    value: function setOverrides(overrides) {\n      var _this4 = this;\n\n      this.overrides.clear();\n      overrides.forEach(function (_ref) {\n        var _ref2 = _slicedToArray(_ref, 2),\n            type = _ref2[0],\n            override = _ref2[1];\n\n        _this4.addOverride(type, override);\n      });\n    }\n  }, {\n    key: \"getAnnotation\",\n    value: function getAnnotation(type) {\n      var annotations = reflection.annotations(type); // Try to find the nearest known Type annotation and make sure that this annotation is an\n      // instance of the type we are looking for, so we can use it for resolution. Note: there might\n      // be multiple known annotations found due to the fact that Components can extend Directives (so\n      // both Directive and Component annotations would be present), so we always check if the known\n      // annotation has the right type.\n\n      for (var i = annotations.length - 1; i >= 0; i--) {\n        var annotation = annotations[i];\n        var isKnownType = annotation instanceof Directive || annotation instanceof Component || annotation instanceof Pipe || annotation instanceof NgModule;\n\n        if (isKnownType) {\n          return annotation instanceof this.type ? annotation : null;\n        }\n      }\n\n      return null;\n    }\n  }, {\n    key: \"resolve\",\n    value: function resolve(type) {\n      var _this5 = this;\n\n      var resolved = this.resolved.get(type) || null;\n\n      if (!resolved) {\n        resolved = this.getAnnotation(type);\n\n        if (resolved) {\n          var overrides = this.overrides.get(type);\n\n          if (overrides) {\n            var overrider = new MetadataOverrider();\n            overrides.forEach(function (override) {\n              resolved = overrider.overrideMetadata(_this5.type, resolved, override);\n            });\n          }\n        }\n\n        this.resolved.set(type, resolved);\n      }\n\n      return resolved;\n    }\n  }]);\n\n  return OverrideResolver;\n}();\n\nvar DirectiveResolver = /*#__PURE__*/function (_OverrideResolver) {\n  _inherits(DirectiveResolver, _OverrideResolver);\n\n  var _super = _createSuper(DirectiveResolver);\n\n  function DirectiveResolver() {\n    _classCallCheck(this, DirectiveResolver);\n\n    return _super.apply(this, arguments);\n  }\n\n  _createClass(DirectiveResolver, [{\n    key: \"type\",\n    get: function get() {\n      return Directive;\n    }\n  }]);\n\n  return DirectiveResolver;\n}(OverrideResolver);\n\nvar ComponentResolver = /*#__PURE__*/function (_OverrideResolver2) {\n  _inherits(ComponentResolver, _OverrideResolver2);\n\n  var _super2 = _createSuper(ComponentResolver);\n\n  function ComponentResolver() {\n    _classCallCheck(this, ComponentResolver);\n\n    return _super2.apply(this, arguments);\n  }\n\n  _createClass(ComponentResolver, [{\n    key: \"type\",\n    get: function get() {\n      return Component;\n    }\n  }]);\n\n  return ComponentResolver;\n}(OverrideResolver);\n\nvar PipeResolver = /*#__PURE__*/function (_OverrideResolver3) {\n  _inherits(PipeResolver, _OverrideResolver3);\n\n  var _super3 = _createSuper(PipeResolver);\n\n  function PipeResolver() {\n    _classCallCheck(this, PipeResolver);\n\n    return _super3.apply(this, arguments);\n  }\n\n  _createClass(PipeResolver, [{\n    key: \"type\",\n    get: function get() {\n      return Pipe;\n    }\n  }]);\n\n  return PipeResolver;\n}(OverrideResolver);\n\nvar NgModuleResolver = /*#__PURE__*/function (_OverrideResolver4) {\n  _inherits(NgModuleResolver, _OverrideResolver4);\n\n  var _super4 = _createSuper(NgModuleResolver);\n\n  function NgModuleResolver() {\n    _classCallCheck(this, NgModuleResolver);\n\n    return _super4.apply(this, arguments);\n  }\n\n  _createClass(NgModuleResolver, [{\n    key: \"type\",\n    get: function get() {\n      return NgModule;\n    }\n  }]);\n\n  return NgModuleResolver;\n}(OverrideResolver);\n/**\n * @license\n * Copyright Google LLC All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.io/license\n */\n\n\nvar TestingModuleOverride;\n\n(function (TestingModuleOverride) {\n  TestingModuleOverride[TestingModuleOverride[\"DECLARATION\"] = 0] = \"DECLARATION\";\n  TestingModuleOverride[TestingModuleOverride[\"OVERRIDE_TEMPLATE\"] = 1] = \"OVERRIDE_TEMPLATE\";\n})(TestingModuleOverride || (TestingModuleOverride = {}));\n\nfunction isTestingModuleOverride(value) {\n  return value === TestingModuleOverride.DECLARATION || value === TestingModuleOverride.OVERRIDE_TEMPLATE;\n}\n\nvar R3TestBedCompiler = /*#__PURE__*/function () {\n  function R3TestBedCompiler(platform, additionalModuleTypes) {\n    _classCallCheck(this, R3TestBedCompiler);\n\n    this.platform = platform;\n    this.additionalModuleTypes = additionalModuleTypes;\n    this.originalComponentResolutionQueue = null; // Testing module configuration\n\n    this.declarations = [];\n    this.imports = [];\n    this.providers = [];\n    this.schemas = []; // Queues of components/directives/pipes that should be recompiled.\n\n    this.pendingComponents = new Set();\n    this.pendingDirectives = new Set();\n    this.pendingPipes = new Set(); // Keep track of all components and directives, so we can patch Providers onto defs later.\n\n    this.seenComponents = new Set();\n    this.seenDirectives = new Set(); // Keep track of overridden modules, so that we can collect all affected ones in the module tree.\n\n    this.overriddenModules = new Set(); // Store resolved styles for Components that have template overrides present and `styleUrls`\n    // defined at the same time.\n\n    this.existingComponentStyles = new Map();\n    this.resolvers = initResolvers();\n    this.componentToModuleScope = new Map(); // Map that keeps initial version of component/directive/pipe defs in case\n    // we compile a Type again, thus overriding respective static fields. This is\n    // required to make sure we restore defs to their initial states between test runs\n    // TODO: we should support the case with multiple defs on a type\n\n    this.initialNgDefs = new Map(); // Array that keeps cleanup operations for initial versions of component/directive/pipe/module\n    // defs in case TestBed makes changes to the originals.\n\n    this.defCleanupOps = [];\n    this._injector = null;\n    this.compilerProviders = null;\n    this.providerOverrides = [];\n    this.rootProviderOverrides = []; // Overrides for injectables with `{providedIn: SomeModule}` need to be tracked and added to that\n    // module's provider list.\n\n    this.providerOverridesByModule = new Map();\n    this.providerOverridesByToken = new Map();\n    this.moduleProvidersOverridden = new Set();\n    this.testModuleRef = null;\n\n    var DynamicTestModule = function DynamicTestModule() {\n      _classCallCheck(this, DynamicTestModule);\n    };\n\n    this.testModuleType = DynamicTestModule;\n  }\n\n  _createClass(R3TestBedCompiler, [{\n    key: \"setCompilerProviders\",\n    value: function setCompilerProviders(providers) {\n      this.compilerProviders = providers;\n      this._injector = null;\n    }\n  }, {\n    key: \"configureTestingModule\",\n    value: function configureTestingModule(moduleDef) {\n      // Enqueue any compilation tasks for the directly declared component.\n      if (moduleDef.declarations !== undefined) {\n        var _this$declarations;\n\n        this.queueTypeArray(moduleDef.declarations, TestingModuleOverride.DECLARATION);\n\n        (_this$declarations = this.declarations).push.apply(_this$declarations, _toConsumableArray(moduleDef.declarations));\n      } // Enqueue any compilation tasks for imported modules.\n\n\n      if (moduleDef.imports !== undefined) {\n        var _this$imports;\n\n        this.queueTypesFromModulesArray(moduleDef.imports);\n\n        (_this$imports = this.imports).push.apply(_this$imports, _toConsumableArray(moduleDef.imports));\n      }\n\n      if (moduleDef.providers !== undefined) {\n        var _this$providers;\n\n        (_this$providers = this.providers).push.apply(_this$providers, _toConsumableArray(moduleDef.providers));\n      }\n\n      if (moduleDef.schemas !== undefined) {\n        var _this$schemas;\n\n        (_this$schemas = this.schemas).push.apply(_this$schemas, _toConsumableArray(moduleDef.schemas));\n      }\n    }\n  }, {\n    key: \"overrideModule\",\n    value: function overrideModule(ngModule, override) {\n      this.overriddenModules.add(ngModule); // Compile the module right away.\n\n      this.resolvers.module.addOverride(ngModule, override);\n      var metadata = this.resolvers.module.resolve(ngModule);\n\n      if (metadata === null) {\n        throw invalidTypeError(ngModule.name, 'NgModule');\n      }\n\n      this.recompileNgModule(ngModule, metadata); // At this point, the module has a valid module def (ɵmod), but the override may have introduced\n      // new declarations or imported modules. Ingest any possible new types and add them to the\n      // current queue.\n\n      this.queueTypesFromModulesArray([ngModule]);\n    }\n  }, {\n    key: \"overrideComponent\",\n    value: function overrideComponent(component, override) {\n      this.resolvers.component.addOverride(component, override);\n      this.pendingComponents.add(component);\n    }\n  }, {\n    key: \"overrideDirective\",\n    value: function overrideDirective(directive, override) {\n      this.resolvers.directive.addOverride(directive, override);\n      this.pendingDirectives.add(directive);\n    }\n  }, {\n    key: \"overridePipe\",\n    value: function overridePipe(pipe, override) {\n      this.resolvers.pipe.addOverride(pipe, override);\n      this.pendingPipes.add(pipe);\n    }\n  }, {\n    key: \"overrideProvider\",\n    value: function overrideProvider(token, provider) {\n      var providerDef;\n\n      if (provider.useFactory !== undefined) {\n        providerDef = {\n          provide: token,\n          useFactory: provider.useFactory,\n          deps: provider.deps || [],\n          multi: provider.multi\n        };\n      } else if (provider.useValue !== undefined) {\n        providerDef = {\n          provide: token,\n          useValue: provider.useValue,\n          multi: provider.multi\n        };\n      } else {\n        providerDef = {\n          provide: token\n        };\n      }\n\n      var injectableDef = typeof token !== 'string' ? ɵgetInjectableDef(token) : null;\n      var providedIn = injectableDef === null ? null : resolveForwardRef(injectableDef.providedIn);\n      var overridesBucket = providedIn === 'root' ? this.rootProviderOverrides : this.providerOverrides;\n      overridesBucket.push(providerDef); // Keep overrides grouped by token as well for fast lookups using token\n\n      this.providerOverridesByToken.set(token, providerDef);\n\n      if (injectableDef !== null && providedIn !== null && typeof providedIn !== 'string') {\n        var existingOverrides = this.providerOverridesByModule.get(providedIn);\n\n        if (existingOverrides !== undefined) {\n          existingOverrides.push(providerDef);\n        } else {\n          this.providerOverridesByModule.set(providedIn, [providerDef]);\n        }\n      }\n    }\n  }, {\n    key: \"overrideTemplateUsingTestingModule\",\n    value: function overrideTemplateUsingTestingModule(type, template) {\n      var _this6 = this;\n\n      var def = type[ɵNG_COMP_DEF];\n\n      var hasStyleUrls = function hasStyleUrls() {\n        var metadata = _this6.resolvers.component.resolve(type);\n\n        return !!metadata.styleUrls && metadata.styleUrls.length > 0;\n      };\n\n      var overrideStyleUrls = !!def && !isComponentDefPendingResolution(type) && hasStyleUrls(); // In Ivy, compiling a component does not require knowing the module providing the\n      // component's scope, so overrideTemplateUsingTestingModule can be implemented purely via\n      // overrideComponent. Important: overriding template requires full Component re-compilation,\n      // which may fail in case styleUrls are also present (thus Component is considered as required\n      // resolution). In order to avoid this, we preemptively set styleUrls to an empty array,\n      // preserve current styles available on Component def and restore styles back once compilation\n      // is complete.\n\n      var override = overrideStyleUrls ? {\n        template: template,\n        styles: [],\n        styleUrls: []\n      } : {\n        template: template\n      };\n      this.overrideComponent(type, {\n        set: override\n      });\n\n      if (overrideStyleUrls && def.styles && def.styles.length > 0) {\n        this.existingComponentStyles.set(type, def.styles);\n      } // Set the component's scope to be the testing module.\n\n\n      this.componentToModuleScope.set(type, TestingModuleOverride.OVERRIDE_TEMPLATE);\n    }\n  }, {\n    key: \"compileComponents\",\n    value: function compileComponents() {\n      return __awaiter(this, void 0, void 0, /*#__PURE__*/_regeneratorRuntime.mark(function _callee() {\n        var _this7 = this;\n\n        var needsAsyncResources, resourceLoader, resolver;\n        return _regeneratorRuntime.wrap(function _callee$(_context) {\n          while (1) {\n            switch (_context.prev = _context.next) {\n              case 0:\n                this.clearComponentResolutionQueue(); // Run compilers for all queued types.\n\n                needsAsyncResources = this.compileTypesSync(); // compileComponents() should not be async unless it needs to be.\n\n                if (!needsAsyncResources) {\n                  _context.next = 6;\n                  break;\n                }\n\n                resolver = function resolver(url) {\n                  if (!resourceLoader) {\n                    resourceLoader = _this7.injector.get(ResourceLoader);\n                  }\n\n                  return Promise.resolve(resourceLoader.get(url));\n                };\n\n                _context.next = 6;\n                return resolveComponentResources(resolver);\n\n              case 6:\n              case \"end\":\n                return _context.stop();\n            }\n          }\n        }, _callee, this);\n      }));\n    }\n  }, {\n    key: \"finalize\",\n    value: function finalize() {\n      // One last compile\n      this.compileTypesSync(); // Create the testing module itself.\n\n      this.compileTestModule();\n      this.applyTransitiveScopes();\n      this.applyProviderOverrides(); // Patch previously stored `styles` Component values (taken from ɵcmp), in case these\n      // Components have `styleUrls` fields defined and template override was requested.\n\n      this.patchComponentsWithExistingStyles(); // Clear the componentToModuleScope map, so that future compilations don't reset the scope of\n      // every component.\n\n      this.componentToModuleScope.clear();\n      var parentInjector = this.platform.injector;\n      this.testModuleRef = new ɵRender3NgModuleRef(this.testModuleType, parentInjector); // ApplicationInitStatus.runInitializers() is marked @internal to core.\n      // Cast it to any before accessing it.\n\n      this.testModuleRef.injector.get(ApplicationInitStatus).runInitializers(); // Set locale ID after running app initializers, since locale information might be updated while\n      // running initializers. This is also consistent with the execution order while bootstrapping an\n      // app (see `packages/core/src/application_ref.ts` file).\n\n      var localeId = this.testModuleRef.injector.get(LOCALE_ID, ɵDEFAULT_LOCALE_ID);\n      ɵsetLocaleId(localeId);\n      return this.testModuleRef;\n    }\n    /**\n     * @internal\n     */\n\n  }, {\n    key: \"_compileNgModuleSync\",\n    value: function _compileNgModuleSync(moduleType) {\n      this.queueTypesFromModulesArray([moduleType]);\n      this.compileTypesSync();\n      this.applyProviderOverrides();\n      this.applyProviderOverridesToModule(moduleType);\n      this.applyTransitiveScopes();\n    }\n    /**\n     * @internal\n     */\n\n  }, {\n    key: \"_compileNgModuleAsync\",\n    value: function _compileNgModuleAsync(moduleType) {\n      return __awaiter(this, void 0, void 0, /*#__PURE__*/_regeneratorRuntime.mark(function _callee2() {\n        return _regeneratorRuntime.wrap(function _callee2$(_context2) {\n          while (1) {\n            switch (_context2.prev = _context2.next) {\n              case 0:\n                this.queueTypesFromModulesArray([moduleType]);\n                _context2.next = 3;\n                return this.compileComponents();\n\n              case 3:\n                this.applyProviderOverrides();\n                this.applyProviderOverridesToModule(moduleType);\n                this.applyTransitiveScopes();\n\n              case 6:\n              case \"end\":\n                return _context2.stop();\n            }\n          }\n        }, _callee2, this);\n      }));\n    }\n    /**\n     * @internal\n     */\n\n  }, {\n    key: \"_getModuleResolver\",\n    value: function _getModuleResolver() {\n      return this.resolvers.module;\n    }\n    /**\n     * @internal\n     */\n\n  }, {\n    key: \"_getComponentFactories\",\n    value: function _getComponentFactories(moduleType) {\n      var _this8 = this;\n\n      return maybeUnwrapFn(moduleType.ɵmod.declarations).reduce(function (factories, declaration) {\n        var componentDef = declaration.ɵcmp;\n        componentDef && factories.push(new ɵRender3ComponentFactory(componentDef, _this8.testModuleRef));\n        return factories;\n      }, []);\n    }\n  }, {\n    key: \"compileTypesSync\",\n    value: function compileTypesSync() {\n      var _this9 = this;\n\n      // Compile all queued components, directives, pipes.\n      var needsAsyncResources = false;\n      this.pendingComponents.forEach(function (declaration) {\n        needsAsyncResources = needsAsyncResources || isComponentDefPendingResolution(declaration);\n\n        var metadata = _this9.resolvers.component.resolve(declaration);\n\n        if (metadata === null) {\n          throw invalidTypeError(declaration.name, 'Component');\n        }\n\n        _this9.maybeStoreNgDef(ɵNG_COMP_DEF, declaration);\n\n        ɵcompileComponent(declaration, metadata);\n      });\n      this.pendingComponents.clear();\n      this.pendingDirectives.forEach(function (declaration) {\n        var metadata = _this9.resolvers.directive.resolve(declaration);\n\n        if (metadata === null) {\n          throw invalidTypeError(declaration.name, 'Directive');\n        }\n\n        _this9.maybeStoreNgDef(ɵNG_DIR_DEF, declaration);\n\n        ɵcompileDirective(declaration, metadata);\n      });\n      this.pendingDirectives.clear();\n      this.pendingPipes.forEach(function (declaration) {\n        var metadata = _this9.resolvers.pipe.resolve(declaration);\n\n        if (metadata === null) {\n          throw invalidTypeError(declaration.name, 'Pipe');\n        }\n\n        _this9.maybeStoreNgDef(ɵNG_PIPE_DEF, declaration);\n\n        ɵcompilePipe(declaration, metadata);\n      });\n      this.pendingPipes.clear();\n      return needsAsyncResources;\n    }\n  }, {\n    key: \"applyTransitiveScopes\",\n    value: function applyTransitiveScopes() {\n      var _this10 = this;\n\n      if (this.overriddenModules.size > 0) {\n        // Module overrides (via `TestBed.overrideModule`) might affect scopes that were previously\n        // calculated and stored in `transitiveCompileScopes`. If module overrides are present,\n        // collect all affected modules and reset scopes to force their re-calculation.\n        var testingModuleDef = this.testModuleType[ɵNG_MOD_DEF];\n        var affectedModules = this.collectModulesAffectedByOverrides(testingModuleDef.imports);\n\n        if (affectedModules.size > 0) {\n          affectedModules.forEach(function (moduleType) {\n            _this10.storeFieldOfDefOnType(moduleType, ɵNG_MOD_DEF, 'transitiveCompileScopes');\n\n            moduleType[ɵNG_MOD_DEF].transitiveCompileScopes = null;\n          });\n        }\n      }\n\n      var moduleToScope = new Map();\n\n      var getScopeOfModule = function getScopeOfModule(moduleType) {\n        if (!moduleToScope.has(moduleType)) {\n          var isTestingModule = isTestingModuleOverride(moduleType);\n          var realType = isTestingModule ? _this10.testModuleType : moduleType;\n          moduleToScope.set(moduleType, ɵtransitiveScopesFor(realType));\n        }\n\n        return moduleToScope.get(moduleType);\n      };\n\n      this.componentToModuleScope.forEach(function (moduleType, componentType) {\n        var moduleScope = getScopeOfModule(moduleType);\n\n        _this10.storeFieldOfDefOnType(componentType, ɵNG_COMP_DEF, 'directiveDefs');\n\n        _this10.storeFieldOfDefOnType(componentType, ɵNG_COMP_DEF, 'pipeDefs'); // `tView` that is stored on component def contains information about directives and pipes\n        // that are in the scope of this component. Patching component scope will cause `tView` to be\n        // changed. Store original `tView` before patching scope, so the `tView` (including scope\n        // information) is restored back to its previous/original state before running next test.\n\n\n        _this10.storeFieldOfDefOnType(componentType, ɵNG_COMP_DEF, 'tView');\n\n        ɵpatchComponentDefWithScope(componentType.ɵcmp, moduleScope);\n      });\n      this.componentToModuleScope.clear();\n    }\n  }, {\n    key: \"applyProviderOverrides\",\n    value: function applyProviderOverrides() {\n      var _this11 = this;\n\n      var maybeApplyOverrides = function maybeApplyOverrides(field) {\n        return function (type) {\n          var resolver = field === ɵNG_COMP_DEF ? _this11.resolvers.component : _this11.resolvers.directive;\n          var metadata = resolver.resolve(type);\n\n          if (_this11.hasProviderOverrides(metadata.providers)) {\n            _this11.patchDefWithProviderOverrides(type, field);\n          }\n        };\n      };\n\n      this.seenComponents.forEach(maybeApplyOverrides(ɵNG_COMP_DEF));\n      this.seenDirectives.forEach(maybeApplyOverrides(ɵNG_DIR_DEF));\n      this.seenComponents.clear();\n      this.seenDirectives.clear();\n    }\n  }, {\n    key: \"applyProviderOverridesToModule\",\n    value: function applyProviderOverridesToModule(moduleType) {\n      if (this.moduleProvidersOverridden.has(moduleType)) {\n        return;\n      }\n\n      this.moduleProvidersOverridden.add(moduleType);\n      var injectorDef = moduleType[ɵNG_INJ_DEF];\n\n      if (this.providerOverridesByToken.size > 0) {\n        var providers = [].concat(_toConsumableArray(injectorDef.providers), _toConsumableArray(this.providerOverridesByModule.get(moduleType) || []));\n\n        if (this.hasProviderOverrides(providers)) {\n          this.maybeStoreNgDef(ɵNG_INJ_DEF, moduleType);\n          this.storeFieldOfDefOnType(moduleType, ɵNG_INJ_DEF, 'providers');\n          injectorDef.providers = this.getOverriddenProviders(providers);\n        } // Apply provider overrides to imported modules recursively\n\n\n        var moduleDef = moduleType[ɵNG_MOD_DEF];\n        var imports = maybeUnwrapFn(moduleDef.imports);\n\n        var _iterator = _createForOfIteratorHelper(imports),\n            _step;\n\n        try {\n          for (_iterator.s(); !(_step = _iterator.n()).done;) {\n            var importedModule = _step.value;\n            this.applyProviderOverridesToModule(importedModule);\n          } // Also override the providers on any ModuleWithProviders imports since those don't appear in\n          // the moduleDef.\n\n        } catch (err) {\n          _iterator.e(err);\n        } finally {\n          _iterator.f();\n        }\n\n        var _iterator2 = _createForOfIteratorHelper(flatten(injectorDef.imports)),\n            _step2;\n\n        try {\n          for (_iterator2.s(); !(_step2 = _iterator2.n()).done;) {\n            var _importedModule = _step2.value;\n\n            if (isModuleWithProviders(_importedModule)) {\n              this.defCleanupOps.push({\n                object: _importedModule,\n                fieldName: 'providers',\n                originalValue: _importedModule.providers\n              });\n              _importedModule.providers = this.getOverriddenProviders(_importedModule.providers);\n            }\n          }\n        } catch (err) {\n          _iterator2.e(err);\n        } finally {\n          _iterator2.f();\n        }\n      }\n    }\n  }, {\n    key: \"patchComponentsWithExistingStyles\",\n    value: function patchComponentsWithExistingStyles() {\n      this.existingComponentStyles.forEach(function (styles, type) {\n        return type[ɵNG_COMP_DEF].styles = styles;\n      });\n      this.existingComponentStyles.clear();\n    }\n  }, {\n    key: \"queueTypeArray\",\n    value: function queueTypeArray(arr, moduleType) {\n      var _iterator3 = _createForOfIteratorHelper(arr),\n          _step3;\n\n      try {\n        for (_iterator3.s(); !(_step3 = _iterator3.n()).done;) {\n          var value = _step3.value;\n\n          if (Array.isArray(value)) {\n            this.queueTypeArray(value, moduleType);\n          } else {\n            this.queueType(value, moduleType);\n          }\n        }\n      } catch (err) {\n        _iterator3.e(err);\n      } finally {\n        _iterator3.f();\n      }\n    }\n  }, {\n    key: \"recompileNgModule\",\n    value: function recompileNgModule(ngModule, metadata) {\n      // Cache the initial ngModuleDef as it will be overwritten.\n      this.maybeStoreNgDef(ɵNG_MOD_DEF, ngModule);\n      this.maybeStoreNgDef(ɵNG_INJ_DEF, ngModule);\n      ɵcompileNgModuleDefs(ngModule, metadata);\n    }\n  }, {\n    key: \"queueType\",\n    value: function queueType(type, moduleType) {\n      var component = this.resolvers.component.resolve(type);\n\n      if (component) {\n        // Check whether a give Type has respective NG def (ɵcmp) and compile if def is\n        // missing. That might happen in case a class without any Angular decorators extends another\n        // class where Component/Directive/Pipe decorator is defined.\n        if (isComponentDefPendingResolution(type) || !type.hasOwnProperty(ɵNG_COMP_DEF)) {\n          this.pendingComponents.add(type);\n        }\n\n        this.seenComponents.add(type); // Keep track of the module which declares this component, so later the component's scope\n        // can be set correctly. If the component has already been recorded here, then one of several\n        // cases is true:\n        // * the module containing the component was imported multiple times (common).\n        // * the component is declared in multiple modules (which is an error).\n        // * the component was in 'declarations' of the testing module, and also in an imported module\n        //   in which case the module scope will be TestingModuleOverride.DECLARATION.\n        // * overrideTemplateUsingTestingModule was called for the component in which case the module\n        //   scope will be TestingModuleOverride.OVERRIDE_TEMPLATE.\n        //\n        // If the component was previously in the testing module's 'declarations' (meaning the\n        // current value is TestingModuleOverride.DECLARATION), then `moduleType` is the component's\n        // real module, which was imported. This pattern is understood to mean that the component\n        // should use its original scope, but that the testing module should also contain the\n        // component in its scope.\n\n        if (!this.componentToModuleScope.has(type) || this.componentToModuleScope.get(type) === TestingModuleOverride.DECLARATION) {\n          this.componentToModuleScope.set(type, moduleType);\n        }\n\n        return;\n      }\n\n      var directive = this.resolvers.directive.resolve(type);\n\n      if (directive) {\n        if (!type.hasOwnProperty(ɵNG_DIR_DEF)) {\n          this.pendingDirectives.add(type);\n        }\n\n        this.seenDirectives.add(type);\n        return;\n      }\n\n      var pipe = this.resolvers.pipe.resolve(type);\n\n      if (pipe && !type.hasOwnProperty(ɵNG_PIPE_DEF)) {\n        this.pendingPipes.add(type);\n        return;\n      }\n    }\n  }, {\n    key: \"queueTypesFromModulesArray\",\n    value: function queueTypesFromModulesArray(arr) {\n      var _this12 = this;\n\n      // Because we may encounter the same NgModule while processing the imports and exports of an\n      // NgModule tree, we cache them in this set so we can skip ones that have already been seen\n      // encountered. In some test setups, this caching resulted in 10X runtime improvement.\n      var processedNgModuleDefs = new Set();\n\n      var queueTypesFromModulesArrayRecur = function queueTypesFromModulesArrayRecur(arr) {\n        var _iterator4 = _createForOfIteratorHelper(arr),\n            _step4;\n\n        try {\n          for (_iterator4.s(); !(_step4 = _iterator4.n()).done;) {\n            var value = _step4.value;\n\n            if (Array.isArray(value)) {\n              queueTypesFromModulesArrayRecur(value);\n            } else if (hasNgModuleDef(value)) {\n              var def = value.ɵmod;\n\n              if (processedNgModuleDefs.has(def)) {\n                continue;\n              }\n\n              processedNgModuleDefs.add(def); // Look through declarations, imports, and exports, and queue\n              // everything found there.\n\n              _this12.queueTypeArray(maybeUnwrapFn(def.declarations), value);\n\n              queueTypesFromModulesArrayRecur(maybeUnwrapFn(def.imports));\n              queueTypesFromModulesArrayRecur(maybeUnwrapFn(def.exports));\n            } else if (isModuleWithProviders(value)) {\n              queueTypesFromModulesArrayRecur([value.ngModule]);\n            }\n          }\n        } catch (err) {\n          _iterator4.e(err);\n        } finally {\n          _iterator4.f();\n        }\n      };\n\n      queueTypesFromModulesArrayRecur(arr);\n    } // When module overrides (via `TestBed.overrideModule`) are present, it might affect all modules\n    // that import (even transitively) an overridden one. For all affected modules we need to\n    // recalculate their scopes for a given test run and restore original scopes at the end. The goal\n    // of this function is to collect all affected modules in a set for further processing. Example:\n    // if we have the following module hierarchy: A -> B -> C (where `->` means `imports`) and module\n    // `C` is overridden, we consider `A` and `B` as affected, since their scopes might become\n    // invalidated with the override.\n\n  }, {\n    key: \"collectModulesAffectedByOverrides\",\n    value: function collectModulesAffectedByOverrides(arr) {\n      var _this13 = this;\n\n      var seenModules = new Set();\n      var affectedModules = new Set();\n\n      var calcAffectedModulesRecur = function calcAffectedModulesRecur(arr, path) {\n        var _iterator5 = _createForOfIteratorHelper(arr),\n            _step5;\n\n        try {\n          for (_iterator5.s(); !(_step5 = _iterator5.n()).done;) {\n            var value = _step5.value;\n\n            if (Array.isArray(value)) {\n              // If the value is an array, just flatten it (by invoking this function recursively),\n              // keeping \"path\" the same.\n              calcAffectedModulesRecur(value, path);\n            } else if (hasNgModuleDef(value)) {\n              if (seenModules.has(value)) {\n                // If we've seen this module before and it's included into \"affected modules\" list, mark\n                // the whole path that leads to that module as affected, but do not descend into its\n                // imports, since we already examined them before.\n                if (affectedModules.has(value)) {\n                  path.forEach(function (item) {\n                    return affectedModules.add(item);\n                  });\n                }\n\n                continue;\n              }\n\n              seenModules.add(value);\n\n              if (_this13.overriddenModules.has(value)) {\n                path.forEach(function (item) {\n                  return affectedModules.add(item);\n                });\n              } // Examine module imports recursively to look for overridden modules.\n\n\n              var moduleDef = value[ɵNG_MOD_DEF];\n              calcAffectedModulesRecur(maybeUnwrapFn(moduleDef.imports), path.concat(value));\n            }\n          }\n        } catch (err) {\n          _iterator5.e(err);\n        } finally {\n          _iterator5.f();\n        }\n      };\n\n      calcAffectedModulesRecur(arr, []);\n      return affectedModules;\n    }\n  }, {\n    key: \"maybeStoreNgDef\",\n    value: function maybeStoreNgDef(prop, type) {\n      if (!this.initialNgDefs.has(type)) {\n        var currentDef = Object.getOwnPropertyDescriptor(type, prop);\n        this.initialNgDefs.set(type, [prop, currentDef]);\n      }\n    }\n  }, {\n    key: \"storeFieldOfDefOnType\",\n    value: function storeFieldOfDefOnType(type, defField, fieldName) {\n      var def = type[defField];\n      var originalValue = def[fieldName];\n      this.defCleanupOps.push({\n        object: def,\n        fieldName: fieldName,\n        originalValue: originalValue\n      });\n    }\n    /**\n     * Clears current components resolution queue, but stores the state of the queue, so we can\n     * restore it later. Clearing the queue is required before we try to compile components (via\n     * `TestBed.compileComponents`), so that component defs are in sync with the resolution queue.\n     */\n\n  }, {\n    key: \"clearComponentResolutionQueue\",\n    value: function clearComponentResolutionQueue() {\n      var _this14 = this;\n\n      if (this.originalComponentResolutionQueue === null) {\n        this.originalComponentResolutionQueue = new Map();\n      }\n\n      clearResolutionOfComponentResourcesQueue().forEach(function (value, key) {\n        return _this14.originalComponentResolutionQueue.set(key, value);\n      });\n    }\n    /*\n     * Restores component resolution queue to the previously saved state. This operation is performed\n     * as a part of restoring the state after completion of the current set of tests (that might\n     * potentially mutate the state).\n     */\n\n  }, {\n    key: \"restoreComponentResolutionQueue\",\n    value: function restoreComponentResolutionQueue() {\n      if (this.originalComponentResolutionQueue !== null) {\n        _restoreComponentResolutionQueue(this.originalComponentResolutionQueue);\n\n        this.originalComponentResolutionQueue = null;\n      }\n    }\n  }, {\n    key: \"restoreOriginalState\",\n    value: function restoreOriginalState() {\n      // Process cleanup ops in reverse order so the field's original value is restored correctly (in\n      // case there were multiple overrides for the same field).\n      forEachRight(this.defCleanupOps, function (op) {\n        op.object[op.fieldName] = op.originalValue;\n      }); // Restore initial component/directive/pipe defs\n\n      this.initialNgDefs.forEach(function (value, type) {\n        var _value = _slicedToArray(value, 2),\n            prop = _value[0],\n            descriptor = _value[1];\n\n        if (!descriptor) {\n          // Delete operations are generally undesirable since they have performance implications\n          // on objects they were applied to. In this particular case, situations where this code\n          // is invoked should be quite rare to cause any noticeable impact, since it's applied\n          // only to some test cases (for example when class with no annotations extends some\n          // @Component) when we need to clear 'ɵcmp' field on a given class to restore\n          // its original state (before applying overrides and running tests).\n          delete type[prop];\n        } else {\n          Object.defineProperty(type, prop, descriptor);\n        }\n      });\n      this.initialNgDefs.clear();\n      this.moduleProvidersOverridden.clear();\n      this.restoreComponentResolutionQueue(); // Restore the locale ID to the default value, this shouldn't be necessary but we never know\n\n      ɵsetLocaleId(ɵDEFAULT_LOCALE_ID);\n    }\n  }, {\n    key: \"compileTestModule\",\n    value: function compileTestModule() {\n      var _this15 = this;\n\n      var RootScopeModule = function RootScopeModule() {\n        _classCallCheck(this, RootScopeModule);\n      };\n\n      ɵcompileNgModuleDefs(RootScopeModule, {\n        providers: _toConsumableArray(this.rootProviderOverrides)\n      });\n      var ngZone = new NgZone({\n        enableLongStackTrace: true\n      });\n      var providers = [{\n        provide: NgZone,\n        useValue: ngZone\n      }, {\n        provide: Compiler,\n        useFactory: function useFactory() {\n          return new R3TestCompiler(_this15);\n        }\n      }].concat(_toConsumableArray(this.providers), _toConsumableArray(this.providerOverrides));\n      var imports = [RootScopeModule, this.additionalModuleTypes, this.imports || []]; // clang-format off\n\n      ɵcompileNgModuleDefs(this.testModuleType, {\n        declarations: this.declarations,\n        imports: imports,\n        schemas: this.schemas,\n        providers: providers\n      },\n      /* allowDuplicateDeclarationsInRoot */\n      true); // clang-format on\n\n      this.applyProviderOverridesToModule(this.testModuleType);\n    }\n  }, {\n    key: \"injector\",\n    get: function get() {\n      if (this._injector !== null) {\n        return this._injector;\n      }\n\n      var providers = [];\n      var compilerOptions = this.platform.injector.get(COMPILER_OPTIONS);\n      compilerOptions.forEach(function (opts) {\n        if (opts.providers) {\n          providers.push(opts.providers);\n        }\n      });\n\n      if (this.compilerProviders !== null) {\n        providers.push.apply(providers, _toConsumableArray(this.compilerProviders));\n      } // TODO(ocombe): make this work with an Injector directly instead of creating a module for it\n\n\n      var CompilerModule = function CompilerModule() {\n        _classCallCheck(this, CompilerModule);\n      };\n\n      ɵcompileNgModuleDefs(CompilerModule, {\n        providers: providers\n      });\n      var CompilerModuleFactory = new ɵNgModuleFactory(CompilerModule);\n      this._injector = CompilerModuleFactory.create(this.platform.injector).injector;\n      return this._injector;\n    } // get overrides for a specific provider (if any)\n\n  }, {\n    key: \"getSingleProviderOverrides\",\n    value: function getSingleProviderOverrides(provider) {\n      var token = getProviderToken(provider);\n      return this.providerOverridesByToken.get(token) || null;\n    }\n  }, {\n    key: \"getProviderOverrides\",\n    value: function getProviderOverrides(providers) {\n      var _this16 = this;\n\n      if (!providers || !providers.length || this.providerOverridesByToken.size === 0) return []; // There are two flattening operations here. The inner flatten() operates on the metadata's\n      // providers and applies a mapping function which retrieves overrides for each incoming\n      // provider. The outer flatten() then flattens the produced overrides array. If this is not\n      // done, the array can contain other empty arrays (e.g. `[[], []]`) which leak into the\n      // providers array and contaminate any error messages that might be generated.\n\n      return flatten(flatten(providers, function (provider) {\n        return _this16.getSingleProviderOverrides(provider) || [];\n      }));\n    }\n  }, {\n    key: \"getOverriddenProviders\",\n    value: function getOverriddenProviders(providers) {\n      var _this17 = this;\n\n      if (!providers || !providers.length || this.providerOverridesByToken.size === 0) return [];\n      var flattenedProviders = flatten(providers);\n      var overrides = this.getProviderOverrides(flattenedProviders);\n      var overriddenProviders = [].concat(_toConsumableArray(flattenedProviders), _toConsumableArray(overrides));\n      var final = [];\n      var seenOverriddenProviders = new Set(); // We iterate through the list of providers in reverse order to make sure provider overrides\n      // take precedence over the values defined in provider list. We also filter out all providers\n      // that have overrides, keeping overridden values only. This is needed, since presence of a\n      // provider with `ngOnDestroy` hook will cause this hook to be registered and invoked later.\n\n      forEachRight(overriddenProviders, function (provider) {\n        var token = getProviderToken(provider);\n\n        if (_this17.providerOverridesByToken.has(token)) {\n          if (!seenOverriddenProviders.has(token)) {\n            seenOverriddenProviders.add(token); // Treat all overridden providers as `{multi: false}` (even if it's a multi-provider) to\n            // make sure that provided override takes highest precedence and is not combined with\n            // other instances of the same multi provider.\n\n            final.unshift(Object.assign(Object.assign({}, provider), {\n              multi: false\n            }));\n          }\n        } else {\n          final.unshift(provider);\n        }\n      });\n      return final;\n    }\n  }, {\n    key: \"hasProviderOverrides\",\n    value: function hasProviderOverrides(providers) {\n      return this.getProviderOverrides(providers).length > 0;\n    }\n  }, {\n    key: \"patchDefWithProviderOverrides\",\n    value: function patchDefWithProviderOverrides(declaration, field) {\n      var _this18 = this;\n\n      var def = declaration[field];\n\n      if (def && def.providersResolver) {\n        this.maybeStoreNgDef(field, declaration);\n        var resolver = def.providersResolver;\n\n        var processProvidersFn = function processProvidersFn(providers) {\n          return _this18.getOverriddenProviders(providers);\n        };\n\n        this.storeFieldOfDefOnType(declaration, field, 'providersResolver');\n\n        def.providersResolver = function (ngDef) {\n          return resolver(ngDef, processProvidersFn);\n        };\n      }\n    }\n  }]);\n\n  return R3TestBedCompiler;\n}();\n\nfunction initResolvers() {\n  return {\n    module: new NgModuleResolver(),\n    component: new ComponentResolver(),\n    directive: new DirectiveResolver(),\n    pipe: new PipeResolver()\n  };\n}\n\nfunction hasNgModuleDef(value) {\n  return value.hasOwnProperty('ɵmod');\n}\n\nfunction maybeUnwrapFn(maybeFn) {\n  return maybeFn instanceof Function ? maybeFn() : maybeFn;\n}\n\nfunction flatten(values, mapFn) {\n  var out = [];\n  values.forEach(function (value) {\n    if (Array.isArray(value)) {\n      out.push.apply(out, _toConsumableArray(flatten(value, mapFn)));\n    } else {\n      out.push(mapFn ? mapFn(value) : value);\n    }\n  });\n  return out;\n}\n\nfunction getProviderField(provider, field) {\n  return provider && typeof provider === 'object' && provider[field];\n}\n\nfunction getProviderToken(provider) {\n  return getProviderField(provider, 'provide') || provider;\n}\n\nfunction isModuleWithProviders(value) {\n  return value.hasOwnProperty('ngModule');\n}\n\nfunction forEachRight(values, fn) {\n  for (var idx = values.length - 1; idx >= 0; idx--) {\n    fn(values[idx], idx);\n  }\n}\n\nfunction invalidTypeError(name, expectedType) {\n  return new Error(\"\".concat(name, \" class doesn't have @\").concat(expectedType, \" decorator or is missing metadata.\"));\n}\n\nvar R3TestCompiler = /*#__PURE__*/function () {\n  function R3TestCompiler(testBed) {\n    _classCallCheck(this, R3TestCompiler);\n\n    this.testBed = testBed;\n  }\n\n  _createClass(R3TestCompiler, [{\n    key: \"compileModuleSync\",\n    value: function compileModuleSync(moduleType) {\n      this.testBed._compileNgModuleSync(moduleType);\n\n      return new ɵNgModuleFactory(moduleType);\n    }\n  }, {\n    key: \"compileModuleAsync\",\n    value: function compileModuleAsync(moduleType) {\n      return __awaiter(this, void 0, void 0, /*#__PURE__*/_regeneratorRuntime.mark(function _callee3() {\n        return _regeneratorRuntime.wrap(function _callee3$(_context3) {\n          while (1) {\n            switch (_context3.prev = _context3.next) {\n              case 0:\n                _context3.next = 2;\n                return this.testBed._compileNgModuleAsync(moduleType);\n\n              case 2:\n                return _context3.abrupt(\"return\", new ɵNgModuleFactory(moduleType));\n\n              case 3:\n              case \"end\":\n                return _context3.stop();\n            }\n          }\n        }, _callee3, this);\n      }));\n    }\n  }, {\n    key: \"compileModuleAndAllComponentsSync\",\n    value: function compileModuleAndAllComponentsSync(moduleType) {\n      var ngModuleFactory = this.compileModuleSync(moduleType);\n\n      var componentFactories = this.testBed._getComponentFactories(moduleType);\n\n      return new ModuleWithComponentFactories(ngModuleFactory, componentFactories);\n    }\n  }, {\n    key: \"compileModuleAndAllComponentsAsync\",\n    value: function compileModuleAndAllComponentsAsync(moduleType) {\n      return __awaiter(this, void 0, void 0, /*#__PURE__*/_regeneratorRuntime.mark(function _callee4() {\n        var ngModuleFactory, componentFactories;\n        return _regeneratorRuntime.wrap(function _callee4$(_context4) {\n          while (1) {\n            switch (_context4.prev = _context4.next) {\n              case 0:\n                _context4.next = 2;\n                return this.compileModuleAsync(moduleType);\n\n              case 2:\n                ngModuleFactory = _context4.sent;\n                componentFactories = this.testBed._getComponentFactories(moduleType);\n                return _context4.abrupt(\"return\", new ModuleWithComponentFactories(ngModuleFactory, componentFactories));\n\n              case 5:\n              case \"end\":\n                return _context4.stop();\n            }\n          }\n        }, _callee4, this);\n      }));\n    }\n  }, {\n    key: \"clearCache\",\n    value: function clearCache() {}\n  }, {\n    key: \"clearCacheFor\",\n    value: function clearCacheFor(type) {}\n  }, {\n    key: \"getModuleId\",\n    value: function getModuleId(moduleType) {\n      var meta = this.testBed._getModuleResolver().resolve(moduleType);\n\n      return meta && meta.id || undefined;\n    }\n  }]);\n\n  return R3TestCompiler;\n}();\n/**\n * @license\n * Copyright Google LLC All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.io/license\n */\n\n/**\n * Whether test modules should be torn down by default.\n * Currently disabled for backwards-compatibility reasons.\n */\n\n\nvar TEARDOWN_TESTING_MODULE_ON_DESTROY_DEFAULT = false;\n/**\n * An abstract class for inserting the root test component element in a platform independent way.\n *\n * @publicApi\n */\n\nvar TestComponentRenderer = /*#__PURE__*/function () {\n  function TestComponentRenderer() {\n    _classCallCheck(this, TestComponentRenderer);\n  }\n\n  _createClass(TestComponentRenderer, [{\n    key: \"insertRootElement\",\n    value: function insertRootElement(rootElementId) {}\n  }, {\n    key: \"removeAllRootElements\",\n    value: function removeAllRootElements() {}\n  }]);\n\n  return TestComponentRenderer;\n}();\n/**\n * @publicApi\n */\n\n\nvar ComponentFixtureAutoDetect = new InjectionToken('ComponentFixtureAutoDetect');\n/**\n * @publicApi\n */\n\nvar ComponentFixtureNoNgZone = new InjectionToken('ComponentFixtureNoNgZone');\n/**\n * @license\n * Copyright Google LLC All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.io/license\n */\n\nvar _nextRootElementId = 0;\n/**\n * @description\n * Configures and initializes environment for unit testing and provides methods for\n * creating components and services in unit tests.\n *\n * TestBed is the primary api for writing unit tests for Angular applications and libraries.\n *\n * Note: Use `TestBed` in tests. It will be set to either `TestBedViewEngine` or `TestBedRender3`\n * according to the compiler used.\n */\n\nvar TestBedRender3 = /*#__PURE__*/function () {\n  function TestBedRender3() {\n    _classCallCheck(this, TestBedRender3);\n\n    // Properties\n    this.platform = null;\n    this.ngModule = null;\n    this._compiler = null;\n    this._testModuleRef = null;\n    this._activeFixtures = [];\n    this._globalCompilationChecked = false;\n  }\n  /**\n   * Initialize the environment for testing with a compiler factory, a PlatformRef, and an\n   * angular module. These are common to every test in the suite.\n   *\n   * This may only be called once, to set up the common providers for the current test\n   * suite on the current platform. If you absolutely need to change the providers,\n   * first use `resetTestEnvironment`.\n   *\n   * Test modules and platforms for individual platforms are available from\n   * '@angular/<platform_name>/testing'.\n   *\n   * @publicApi\n   */\n\n\n  _createClass(TestBedRender3, [{\n    key: \"initTestEnvironment\",\n    value:\n    /**\n     * Initialize the environment for testing with a compiler factory, a PlatformRef, and an\n     * angular module. These are common to every test in the suite.\n     *\n     * This may only be called once, to set up the common providers for the current test\n     * suite on the current platform. If you absolutely need to change the providers,\n     * first use `resetTestEnvironment`.\n     *\n     * Test modules and platforms for individual platforms are available from\n     * '@angular/<platform_name>/testing'.\n     *\n     * @publicApi\n     */\n    function initTestEnvironment(ngModule, platform, summariesOrOptions) {\n      if (this.platform || this.ngModule) {\n        throw new Error('Cannot set base providers because it has already been called');\n      } // If `summariesOrOptions` is a function, it means that it's\n      // an AOT summaries factory which Ivy doesn't support.\n\n\n      TestBedRender3._environmentTeardownOptions = typeof summariesOrOptions === 'function' ? undefined : summariesOrOptions === null || summariesOrOptions === void 0 ? void 0 : summariesOrOptions.teardown;\n      this.platform = platform;\n      this.ngModule = ngModule;\n      this._compiler = new R3TestBedCompiler(this.platform, this.ngModule);\n    }\n    /**\n     * Reset the providers for the test injector.\n     *\n     * @publicApi\n     */\n\n  }, {\n    key: \"resetTestEnvironment\",\n    value: function resetTestEnvironment() {\n      this.resetTestingModule();\n      this._compiler = null;\n      this.platform = null;\n      this.ngModule = null;\n      TestBedRender3._environmentTeardownOptions = undefined;\n    }\n  }, {\n    key: \"resetTestingModule\",\n    value: function resetTestingModule() {\n      this.checkGlobalCompilationFinished();\n      ɵresetCompiledComponents();\n\n      if (this._compiler !== null) {\n        this.compiler.restoreOriginalState();\n      }\n\n      this._compiler = new R3TestBedCompiler(this.platform, this.ngModule); // We have to chain a couple of try/finally blocks, because each step can\n      // throw errors and we don't want it to interrupt the next step and we also\n      // want an error to be thrown at the end.\n\n      try {\n        this.destroyActiveFixtures();\n      } finally {\n        try {\n          if (this.shouldTearDownTestingModule()) {\n            this.tearDownTestingModule();\n          }\n        } finally {\n          this._testModuleRef = null;\n          this._instanceTeardownOptions = undefined;\n        }\n      }\n    }\n  }, {\n    key: \"configureCompiler\",\n    value: function configureCompiler(config) {\n      if (config.useJit != null) {\n        throw new Error('the Render3 compiler JiT mode is not configurable !');\n      }\n\n      if (config.providers !== undefined) {\n        this.compiler.setCompilerProviders(config.providers);\n      }\n    }\n  }, {\n    key: \"configureTestingModule\",\n    value: function configureTestingModule(moduleDef) {\n      this.assertNotInstantiated('R3TestBed.configureTestingModule', 'configure the test module'); // Always re-assign the teardown options, even if they're undefined.\n      // This ensures that we don't carry the options between tests.\n\n      this._instanceTeardownOptions = moduleDef.teardown;\n      this.compiler.configureTestingModule(moduleDef);\n    }\n  }, {\n    key: \"compileComponents\",\n    value: function compileComponents() {\n      return this.compiler.compileComponents();\n    }\n  }, {\n    key: \"inject\",\n    value: function inject(token, notFoundValue, flags) {\n      if (token === TestBedRender3) {\n        return this;\n      }\n\n      var UNDEFINED = {};\n      var result = this.testModuleRef.injector.get(token, UNDEFINED, flags);\n      return result === UNDEFINED ? this.compiler.injector.get(token, notFoundValue, flags) : result;\n    }\n    /** @deprecated from v9.0.0 use TestBed.inject */\n\n  }, {\n    key: \"get\",\n    value: function get(token) {\n      var notFoundValue = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : Injector.THROW_IF_NOT_FOUND;\n      var flags = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : InjectFlags.Default;\n      return this.inject(token, notFoundValue, flags);\n    }\n  }, {\n    key: \"execute\",\n    value: function execute(tokens, fn, context) {\n      var _this19 = this;\n\n      var params = tokens.map(function (t) {\n        return _this19.inject(t);\n      });\n      return fn.apply(context, params);\n    }\n  }, {\n    key: \"overrideModule\",\n    value: function overrideModule(ngModule, override) {\n      this.assertNotInstantiated('overrideModule', 'override module metadata');\n      this.compiler.overrideModule(ngModule, override);\n    }\n  }, {\n    key: \"overrideComponent\",\n    value: function overrideComponent(component, override) {\n      this.assertNotInstantiated('overrideComponent', 'override component metadata');\n      this.compiler.overrideComponent(component, override);\n    }\n  }, {\n    key: \"overrideTemplateUsingTestingModule\",\n    value: function overrideTemplateUsingTestingModule(component, template) {\n      this.assertNotInstantiated('R3TestBed.overrideTemplateUsingTestingModule', 'Cannot override template when the test module has already been instantiated');\n      this.compiler.overrideTemplateUsingTestingModule(component, template);\n    }\n  }, {\n    key: \"overrideDirective\",\n    value: function overrideDirective(directive, override) {\n      this.assertNotInstantiated('overrideDirective', 'override directive metadata');\n      this.compiler.overrideDirective(directive, override);\n    }\n  }, {\n    key: \"overridePipe\",\n    value: function overridePipe(pipe, override) {\n      this.assertNotInstantiated('overridePipe', 'override pipe metadata');\n      this.compiler.overridePipe(pipe, override);\n    }\n    /**\n     * Overwrites all providers for the given token with the given provider definition.\n     */\n\n  }, {\n    key: \"overrideProvider\",\n    value: function overrideProvider(token, provider) {\n      this.assertNotInstantiated('overrideProvider', 'override provider');\n      this.compiler.overrideProvider(token, provider);\n    }\n  }, {\n    key: \"createComponent\",\n    value: function createComponent(type) {\n      var _this20 = this;\n\n      var testComponentRenderer = this.inject(TestComponentRenderer);\n      var rootElId = \"root\".concat(_nextRootElementId++);\n      testComponentRenderer.insertRootElement(rootElId);\n      var componentDef = type.ɵcmp;\n\n      if (!componentDef) {\n        throw new Error(\"It looks like '\".concat(ɵstringify(type), \"' has not been IVY compiled - it has no '\\u0275cmp' field\"));\n      } // TODO: Don't cast as `InjectionToken<boolean>`, proper type is boolean[]\n\n\n      var noNgZone = this.inject(ComponentFixtureNoNgZone, false); // TODO: Don't cast as `InjectionToken<boolean>`, proper type is boolean[]\n\n      var autoDetect = this.inject(ComponentFixtureAutoDetect, false);\n      var ngZone = noNgZone ? null : this.inject(NgZone, null);\n      var componentFactory = new ɵRender3ComponentFactory(componentDef);\n\n      var initComponent = function initComponent() {\n        var componentRef = componentFactory.create(Injector.NULL, [], \"#\".concat(rootElId), _this20.testModuleRef);\n        return new ComponentFixture(componentRef, ngZone, autoDetect);\n      };\n\n      var fixture = ngZone ? ngZone.run(initComponent) : initComponent();\n\n      this._activeFixtures.push(fixture);\n\n      return fixture;\n    }\n    /**\n     * @internal strip this from published d.ts files due to\n     * https://github.com/microsoft/TypeScript/issues/36216\n     */\n\n  }, {\n    key: \"compiler\",\n    get: function get() {\n      if (this._compiler === null) {\n        throw new Error(\"Need to call TestBed.initTestEnvironment() first\");\n      }\n\n      return this._compiler;\n    }\n    /**\n     * @internal strip this from published d.ts files due to\n     * https://github.com/microsoft/TypeScript/issues/36216\n     */\n\n  }, {\n    key: \"testModuleRef\",\n    get: function get() {\n      if (this._testModuleRef === null) {\n        this._testModuleRef = this.compiler.finalize();\n      }\n\n      return this._testModuleRef;\n    }\n  }, {\n    key: \"assertNotInstantiated\",\n    value: function assertNotInstantiated(methodName, methodDescription) {\n      if (this._testModuleRef !== null) {\n        throw new Error(\"Cannot \".concat(methodDescription, \" when the test module has already been instantiated. \") + \"Make sure you are not using `inject` before `\".concat(methodName, \"`.\"));\n      }\n    }\n    /**\n     * Check whether the module scoping queue should be flushed, and flush it if needed.\n     *\n     * When the TestBed is reset, it clears the JIT module compilation queue, cancelling any\n     * in-progress module compilation. This creates a potential hazard - the very first time the\n     * TestBed is initialized (or if it's reset without being initialized), there may be pending\n     * compilations of modules declared in global scope. These compilations should be finished.\n     *\n     * To ensure that globally declared modules have their components scoped properly, this function\n     * is called whenever TestBed is initialized or reset. The _first_ time that this happens, prior\n     * to any other operations, the scoping queue is flushed.\n     */\n\n  }, {\n    key: \"checkGlobalCompilationFinished\",\n    value: function checkGlobalCompilationFinished() {\n      // Checking _testNgModuleRef is null should not be necessary, but is left in as an additional\n      // guard that compilations queued in tests (after instantiation) are never flushed accidentally.\n      if (!this._globalCompilationChecked && this._testModuleRef === null) {\n        ɵflushModuleScopingQueueAsMuchAsPossible();\n      }\n\n      this._globalCompilationChecked = true;\n    }\n  }, {\n    key: \"destroyActiveFixtures\",\n    value: function destroyActiveFixtures() {\n      var errorCount = 0;\n\n      this._activeFixtures.forEach(function (fixture) {\n        try {\n          fixture.destroy();\n        } catch (e) {\n          errorCount++;\n          console.error('Error during cleanup of component', {\n            component: fixture.componentInstance,\n            stacktrace: e\n          });\n        }\n      });\n\n      this._activeFixtures = [];\n\n      if (errorCount > 0 && this.shouldRethrowTeardownErrors()) {\n        throw Error(\"\".concat(errorCount, \" \").concat(errorCount === 1 ? 'component' : 'components', \" \") + \"threw errors during cleanup\");\n      }\n    }\n  }, {\n    key: \"shouldRethrowTeardownErrors\",\n    value: function shouldRethrowTeardownErrors() {\n      var _a, _b;\n\n      var instanceOptions = this._instanceTeardownOptions;\n      var environmentOptions = TestBedRender3._environmentTeardownOptions; // If the new teardown behavior hasn't been configured, preserve the old behavior.\n\n      if (!instanceOptions && !environmentOptions) {\n        return false;\n      } // Otherwise use the configured behavior or default to rethrowing.\n\n\n      return (_b = (_a = instanceOptions === null || instanceOptions === void 0 ? void 0 : instanceOptions.rethrowErrors) !== null && _a !== void 0 ? _a : environmentOptions === null || environmentOptions === void 0 ? void 0 : environmentOptions.rethrowErrors) !== null && _b !== void 0 ? _b : true;\n    }\n  }, {\n    key: \"shouldTearDownTestingModule\",\n    value: function shouldTearDownTestingModule() {\n      var _a, _b, _c, _d;\n\n      return (_d = (_b = (_a = this._instanceTeardownOptions) === null || _a === void 0 ? void 0 : _a.destroyAfterEach) !== null && _b !== void 0 ? _b : (_c = TestBedRender3._environmentTeardownOptions) === null || _c === void 0 ? void 0 : _c.destroyAfterEach) !== null && _d !== void 0 ? _d : TEARDOWN_TESTING_MODULE_ON_DESTROY_DEFAULT;\n    }\n  }, {\n    key: \"tearDownTestingModule\",\n    value: function tearDownTestingModule() {\n      var _a; // If the module ref has already been destroyed, we won't be able to get a test renderer.\n\n\n      if (this._testModuleRef === null) {\n        return;\n      } // Resolve the renderer ahead of time, because we want to remove the root elements as the very\n      // last step, but the injector will be destroyed as a part of the module ref destruction.\n\n\n      var testRenderer = this.inject(TestComponentRenderer);\n\n      try {\n        this._testModuleRef.destroy();\n      } catch (e) {\n        if (this.shouldRethrowTeardownErrors()) {\n          throw e;\n        } else {\n          console.error('Error during cleanup of a testing module', {\n            component: this._testModuleRef.instance,\n            stacktrace: e\n          });\n        }\n      } finally {\n        (_a = testRenderer.removeAllRootElements) === null || _a === void 0 ? void 0 : _a.call(testRenderer);\n      }\n    }\n  }], [{\n    key: \"initTestEnvironment\",\n    value: function initTestEnvironment(ngModule, platform, summariesOrOptions) {\n      var testBed = _getTestBedRender3();\n\n      testBed.initTestEnvironment(ngModule, platform, summariesOrOptions);\n      return testBed;\n    }\n    /**\n     * Reset the providers for the test injector.\n     *\n     * @publicApi\n     */\n\n  }, {\n    key: \"resetTestEnvironment\",\n    value: function resetTestEnvironment() {\n      _getTestBedRender3().resetTestEnvironment();\n    }\n  }, {\n    key: \"configureCompiler\",\n    value: function configureCompiler(config) {\n      _getTestBedRender3().configureCompiler(config);\n\n      return TestBedRender3;\n    }\n    /**\n     * Allows overriding default providers, directives, pipes, modules of the test injector,\n     * which are defined in test_injector.js\n     */\n\n  }, {\n    key: \"configureTestingModule\",\n    value: function configureTestingModule(moduleDef) {\n      _getTestBedRender3().configureTestingModule(moduleDef);\n\n      return TestBedRender3;\n    }\n    /**\n     * Compile components with a `templateUrl` for the test's NgModule.\n     * It is necessary to call this function\n     * as fetching urls is asynchronous.\n     */\n\n  }, {\n    key: \"compileComponents\",\n    value: function compileComponents() {\n      return _getTestBedRender3().compileComponents();\n    }\n  }, {\n    key: \"overrideModule\",\n    value: function overrideModule(ngModule, override) {\n      _getTestBedRender3().overrideModule(ngModule, override);\n\n      return TestBedRender3;\n    }\n  }, {\n    key: \"overrideComponent\",\n    value: function overrideComponent(component, override) {\n      _getTestBedRender3().overrideComponent(component, override);\n\n      return TestBedRender3;\n    }\n  }, {\n    key: \"overrideDirective\",\n    value: function overrideDirective(directive, override) {\n      _getTestBedRender3().overrideDirective(directive, override);\n\n      return TestBedRender3;\n    }\n  }, {\n    key: \"overridePipe\",\n    value: function overridePipe(pipe, override) {\n      _getTestBedRender3().overridePipe(pipe, override);\n\n      return TestBedRender3;\n    }\n  }, {\n    key: \"overrideTemplate\",\n    value: function overrideTemplate(component, template) {\n      _getTestBedRender3().overrideComponent(component, {\n        set: {\n          template: template,\n          templateUrl: null\n        }\n      });\n\n      return TestBedRender3;\n    }\n    /**\n     * Overrides the template of the given component, compiling the template\n     * in the context of the TestingModule.\n     *\n     * Note: This works for JIT and AOTed components as well.\n     */\n\n  }, {\n    key: \"overrideTemplateUsingTestingModule\",\n    value: function overrideTemplateUsingTestingModule(component, template) {\n      _getTestBedRender3().overrideTemplateUsingTestingModule(component, template);\n\n      return TestBedRender3;\n    }\n  }, {\n    key: \"overrideProvider\",\n    value: function overrideProvider(token, provider) {\n      _getTestBedRender3().overrideProvider(token, provider);\n\n      return TestBedRender3;\n    }\n  }, {\n    key: \"inject\",\n    value: function inject(token, notFoundValue, flags) {\n      return _getTestBedRender3().inject(token, notFoundValue, flags);\n    }\n    /** @deprecated from v9.0.0 use TestBed.inject */\n\n  }, {\n    key: \"get\",\n    value: function get(token) {\n      var notFoundValue = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : Injector.THROW_IF_NOT_FOUND;\n      var flags = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : InjectFlags.Default;\n      return _getTestBedRender3().inject(token, notFoundValue, flags);\n    }\n  }, {\n    key: \"createComponent\",\n    value: function createComponent(component) {\n      return _getTestBedRender3().createComponent(component);\n    }\n  }, {\n    key: \"resetTestingModule\",\n    value: function resetTestingModule() {\n      _getTestBedRender3().resetTestingModule();\n\n      return TestBedRender3;\n    }\n  }, {\n    key: \"shouldTearDownTestingModule\",\n    value: function shouldTearDownTestingModule() {\n      return _getTestBedRender3().shouldTearDownTestingModule();\n    }\n  }, {\n    key: \"tearDownTestingModule\",\n    value: function tearDownTestingModule() {\n      _getTestBedRender3().tearDownTestingModule();\n    }\n  }]);\n\n  return TestBedRender3;\n}();\n\nvar testBed;\n\nfunction _getTestBedRender3() {\n  return testBed = testBed || new TestBedRender3();\n}\n/**\n * @license\n * Copyright Google LLC All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.io/license\n */\n\n\nfunction unimplemented() {\n  throw Error('unimplemented');\n}\n/**\n * Special interface to the compiler only used by testing\n *\n * @publicApi\n */\n\n\nvar TestingCompiler = /*#__PURE__*/function (_Compiler) {\n  _inherits(TestingCompiler, _Compiler);\n\n  var _super5 = _createSuper(TestingCompiler);\n\n  function TestingCompiler() {\n    _classCallCheck(this, TestingCompiler);\n\n    return _super5.apply(this, arguments);\n  }\n\n  _createClass(TestingCompiler, [{\n    key: \"injector\",\n    get: function get() {\n      throw unimplemented();\n    }\n  }, {\n    key: \"overrideModule\",\n    value: function overrideModule(module, overrides) {\n      throw unimplemented();\n    }\n  }, {\n    key: \"overrideDirective\",\n    value: function overrideDirective(directive, overrides) {\n      throw unimplemented();\n    }\n  }, {\n    key: \"overrideComponent\",\n    value: function overrideComponent(component, overrides) {\n      throw unimplemented();\n    }\n  }, {\n    key: \"overridePipe\",\n    value: function overridePipe(directive, overrides) {\n      throw unimplemented();\n    }\n    /**\n     * Allows to pass the compile summary from AOT compilation to the JIT compiler,\n     * so that it can use the code generated by AOT.\n     */\n\n  }, {\n    key: \"loadAotSummaries\",\n    value: function loadAotSummaries(summaries) {\n      throw unimplemented();\n    }\n    /**\n     * Gets the component factory for the given component.\n     * This assumes that the component has been compiled before calling this call using\n     * `compileModuleAndAllComponents*`.\n     */\n\n  }, {\n    key: \"getComponentFactory\",\n    value: function getComponentFactory(component) {\n      throw unimplemented();\n    }\n    /**\n     * Returns the component type that is stored in the given error.\n     * This can be used for errors created by compileModule...\n     */\n\n  }, {\n    key: \"getComponentFromError\",\n    value: function getComponentFromError(error) {\n      throw unimplemented();\n    }\n  }]);\n\n  return TestingCompiler;\n}(Compiler);\n\nTestingCompiler.ɵfac = /*@__PURE__*/function () {\n  var ɵTestingCompiler_BaseFactory;\n  return function TestingCompiler_Factory(t) {\n    return (ɵTestingCompiler_BaseFactory || (ɵTestingCompiler_BaseFactory = ɵngcc0.ɵɵgetInheritedFactory(TestingCompiler)))(t || TestingCompiler);\n  };\n}();\n\nTestingCompiler.ɵprov = /*@__PURE__*/ɵngcc0.ɵɵdefineInjectable({\n  token: TestingCompiler,\n  factory: TestingCompiler.ɵfac\n});\n\n(function () {\n  (typeof ngDevMode === \"undefined\" || ngDevMode) && ɵngcc0.ɵsetClassMetadata(TestingCompiler, [{\n    type: Injectable\n  }], null, null);\n})();\n/**\n * A factory for creating a Compiler\n *\n * @publicApi\n */\n\n\nvar TestingCompilerFactory = function TestingCompilerFactory() {\n  _classCallCheck(this, TestingCompilerFactory);\n};\n/**\n * @license\n * Copyright Google LLC All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.io/license\n */\n\n\nvar _nextRootElementId$1 = 0;\n/**\n * @description\n * Configures and initializes environment for unit testing and provides methods for\n * creating components and services in unit tests.\n *\n * `TestBed` is the primary api for writing unit tests for Angular applications and libraries.\n *\n * Note: Use `TestBed` in tests. It will be set to either `TestBedViewEngine` or `TestBedRender3`\n * according to the compiler used.\n */\n\nvar TestBedViewEngine = /*#__PURE__*/function () {\n  function TestBedViewEngine() {\n    _classCallCheck(this, TestBedViewEngine);\n\n    this._instantiated = false;\n    this._compiler = null;\n    this._moduleRef = null;\n    this._moduleFactory = null;\n    this._pendingModuleFactory = null;\n    this._compilerOptions = [];\n    this._moduleOverrides = [];\n    this._componentOverrides = [];\n    this._directiveOverrides = [];\n    this._pipeOverrides = [];\n    this._providers = [];\n    this._declarations = [];\n    this._imports = [];\n    this._schemas = [];\n    this._activeFixtures = [];\n\n    this._testEnvAotSummaries = function () {\n      return [];\n    };\n\n    this._aotSummaries = [];\n    this._templateOverrides = [];\n    this._isRoot = true;\n    this._rootProviderOverrides = [];\n    this.platform = null;\n    this.ngModule = null;\n  }\n  /**\n   * Initialize the environment for testing with a compiler factory, a PlatformRef, and an\n   * angular module. These are common to every test in the suite.\n   *\n   * This may only be called once, to set up the common providers for the current test\n   * suite on the current platform. If you absolutely need to change the providers,\n   * first use `resetTestEnvironment`.\n   *\n   * Test modules and platforms for individual platforms are available from\n   * '@angular/<platform_name>/testing'.\n   */\n\n\n  _createClass(TestBedViewEngine, [{\n    key: \"initTestEnvironment\",\n    value:\n    /**\n     * Initialize the environment for testing with a compiler factory, a PlatformRef, and an\n     * angular module. These are common to every test in the suite.\n     *\n     * This may only be called once, to set up the common providers for the current test\n     * suite on the current platform. If you absolutely need to change the providers,\n     * first use `resetTestEnvironment`.\n     *\n     * Test modules and platforms for individual platforms are available from\n     * '@angular/<platform_name>/testing'.\n     */\n    function initTestEnvironment(ngModule, platform, summariesOrOptions) {\n      if (this.platform || this.ngModule) {\n        throw new Error('Cannot set base providers because it has already been called');\n      }\n\n      this.platform = platform;\n      this.ngModule = ngModule;\n\n      if (typeof summariesOrOptions === 'function') {\n        this._testEnvAotSummaries = summariesOrOptions;\n        TestBedViewEngine._environmentTeardownOptions = undefined;\n      } else {\n        this._testEnvAotSummaries = (summariesOrOptions === null || summariesOrOptions === void 0 ? void 0 : summariesOrOptions.aotSummaries) || function () {\n          return [];\n        };\n\n        TestBedViewEngine._environmentTeardownOptions = summariesOrOptions === null || summariesOrOptions === void 0 ? void 0 : summariesOrOptions.teardown;\n      }\n    }\n    /**\n     * Reset the providers for the test injector.\n     */\n\n  }, {\n    key: \"resetTestEnvironment\",\n    value: function resetTestEnvironment() {\n      this.resetTestingModule();\n      this.platform = null;\n      this.ngModule = null;\n\n      this._testEnvAotSummaries = function () {\n        return [];\n      };\n\n      TestBedViewEngine._environmentTeardownOptions = undefined;\n    }\n  }, {\n    key: \"resetTestingModule\",\n    value: function resetTestingModule() {\n      ɵclearOverrides();\n      this._aotSummaries = [];\n      this._templateOverrides = [];\n      this._compiler = null;\n      this._moduleOverrides = [];\n      this._componentOverrides = [];\n      this._directiveOverrides = [];\n      this._pipeOverrides = [];\n      this._isRoot = true;\n      this._rootProviderOverrides = [];\n      this._moduleFactory = null;\n      this._pendingModuleFactory = null;\n      this._compilerOptions = [];\n      this._providers = [];\n      this._declarations = [];\n      this._imports = [];\n      this._schemas = []; // We have to chain a couple of try/finally blocks, because each step can\n      // throw errors and we don't want it to interrupt the next step and we also\n      // want an error to be thrown at the end.\n\n      try {\n        this.destroyActiveFixtures();\n      } finally {\n        try {\n          if (this.shouldTearDownTestingModule()) {\n            this.tearDownTestingModule();\n          }\n        } finally {\n          this._moduleRef = null;\n          this._instanceTeardownOptions = undefined;\n          this._instantiated = false;\n        }\n      }\n    }\n  }, {\n    key: \"configureCompiler\",\n    value: function configureCompiler(config) {\n      this._assertNotInstantiated('TestBed.configureCompiler', 'configure the compiler');\n\n      this._compilerOptions.push(config);\n    }\n  }, {\n    key: \"configureTestingModule\",\n    value: function configureTestingModule(moduleDef) {\n      this._assertNotInstantiated('TestBed.configureTestingModule', 'configure the test module');\n\n      if (moduleDef.providers) {\n        var _this$_providers;\n\n        (_this$_providers = this._providers).push.apply(_this$_providers, _toConsumableArray(moduleDef.providers));\n      }\n\n      if (moduleDef.declarations) {\n        var _this$_declarations;\n\n        (_this$_declarations = this._declarations).push.apply(_this$_declarations, _toConsumableArray(moduleDef.declarations));\n      }\n\n      if (moduleDef.imports) {\n        var _this$_imports;\n\n        (_this$_imports = this._imports).push.apply(_this$_imports, _toConsumableArray(moduleDef.imports));\n      }\n\n      if (moduleDef.schemas) {\n        var _this$_schemas;\n\n        (_this$_schemas = this._schemas).push.apply(_this$_schemas, _toConsumableArray(moduleDef.schemas));\n      }\n\n      if (moduleDef.aotSummaries) {\n        this._aotSummaries.push(moduleDef.aotSummaries);\n      } // Always re-assign the teardown options, even if they're undefined.\n      // This ensures that we don't carry the options between tests.\n\n\n      this._instanceTeardownOptions = moduleDef.teardown;\n    }\n  }, {\n    key: \"compileComponents\",\n    value: function compileComponents() {\n      var _this21 = this;\n\n      if (this._moduleFactory || this._instantiated) {\n        return Promise.resolve(null);\n      }\n\n      var moduleType = this._createCompilerAndModule();\n\n      this._pendingModuleFactory = moduleType;\n      return this._compiler.compileModuleAndAllComponentsAsync(moduleType).then(function (result) {\n        // If the module mismatches by the time the promise resolves, it means that the module has\n        // already been destroyed and a new compilation has started. If that's the case, avoid\n        // overwriting the module factory, because it can cause downstream errors.\n        if (_this21._pendingModuleFactory === moduleType) {\n          _this21._moduleFactory = result.ngModuleFactory;\n          _this21._pendingModuleFactory = null;\n        }\n      });\n    }\n  }, {\n    key: \"_initIfNeeded\",\n    value: function _initIfNeeded() {\n      if (this._instantiated) {\n        return;\n      }\n\n      if (!this._moduleFactory) {\n        try {\n          var moduleType = this._createCompilerAndModule();\n\n          this._moduleFactory = this._compiler.compileModuleAndAllComponentsSync(moduleType).ngModuleFactory;\n        } catch (e) {\n          var errorCompType = this._compiler.getComponentFromError(e);\n\n          if (errorCompType) {\n            throw new Error(\"This test module uses the component \".concat(ɵstringify(errorCompType), \" which is using a \\\"templateUrl\\\" or \\\"styleUrls\\\", but they were never compiled. \") + \"Please call \\\"TestBed.compileComponents\\\" before your test.\");\n          } else {\n            throw e;\n          }\n        }\n      }\n\n      var _iterator6 = _createForOfIteratorHelper(this._templateOverrides),\n          _step6;\n\n      try {\n        for (_iterator6.s(); !(_step6 = _iterator6.n()).done;) {\n          var _step6$value = _step6.value,\n              component = _step6$value.component,\n              templateOf = _step6$value.templateOf;\n\n          var compFactory = this._compiler.getComponentFactory(templateOf);\n\n          ɵoverrideComponentView(component, compFactory);\n        }\n      } catch (err) {\n        _iterator6.e(err);\n      } finally {\n        _iterator6.f();\n      }\n\n      var ngZone = new NgZone({\n        enableLongStackTrace: true,\n        shouldCoalesceEventChangeDetection: false\n      });\n      var providers = [{\n        provide: NgZone,\n        useValue: ngZone\n      }];\n      var ngZoneInjector = Injector.create({\n        providers: providers,\n        parent: this.platform.injector,\n        name: this._moduleFactory.moduleType.name\n      });\n      this._moduleRef = this._moduleFactory.create(ngZoneInjector); // ApplicationInitStatus.runInitializers() is marked @internal to core. So casting to any\n      // before accessing it.\n\n      this._moduleRef.injector.get(ApplicationInitStatus).runInitializers();\n\n      this._instantiated = true;\n    }\n  }, {\n    key: \"_createCompilerAndModule\",\n    value: function _createCompilerAndModule() {\n      var _this22 = this;\n\n      var providers = this._providers.concat([{\n        provide: TestBed,\n        useValue: this\n      }]);\n\n      var declarations = [].concat(_toConsumableArray(this._declarations), _toConsumableArray(this._templateOverrides.map(function (entry) {\n        return entry.templateOf;\n      })));\n      var rootScopeImports = [];\n      var rootProviderOverrides = this._rootProviderOverrides;\n\n      if (this._isRoot) {\n        var RootScopeModule = function RootScopeModule() {\n          _classCallCheck(this, RootScopeModule);\n        };\n\n        RootScopeModule.decorators = [{\n          type: NgModule,\n          args: [{\n            providers: _toConsumableArray(rootProviderOverrides),\n            jit: true\n          }]\n        }];\n        rootScopeImports.push(RootScopeModule);\n      }\n\n      providers.push({\n        provide: ɵINJECTOR_SCOPE,\n        useValue: this._isRoot ? 'root' : null\n      });\n      var imports = [rootScopeImports, this.ngModule, this._imports];\n      var schemas = this._schemas;\n\n      var DynamicTestModule = function DynamicTestModule() {\n        _classCallCheck(this, DynamicTestModule);\n      };\n\n      DynamicTestModule.decorators = [{\n        type: NgModule,\n        args: [{\n          providers: providers,\n          declarations: declarations,\n          imports: imports,\n          schemas: schemas,\n          jit: true\n        }]\n      }];\n      var compilerFactory = this.platform.injector.get(TestingCompilerFactory);\n      this._compiler = compilerFactory.createTestingCompiler(this._compilerOptions);\n\n      for (var _i = 0, _arr = [this._testEnvAotSummaries].concat(_toConsumableArray(this._aotSummaries)); _i < _arr.length; _i++) {\n        var summary = _arr[_i];\n\n        this._compiler.loadAotSummaries(summary);\n      }\n\n      this._moduleOverrides.forEach(function (entry) {\n        return _this22._compiler.overrideModule(entry[0], entry[1]);\n      });\n\n      this._componentOverrides.forEach(function (entry) {\n        return _this22._compiler.overrideComponent(entry[0], entry[1]);\n      });\n\n      this._directiveOverrides.forEach(function (entry) {\n        return _this22._compiler.overrideDirective(entry[0], entry[1]);\n      });\n\n      this._pipeOverrides.forEach(function (entry) {\n        return _this22._compiler.overridePipe(entry[0], entry[1]);\n      });\n\n      return DynamicTestModule;\n    }\n  }, {\n    key: \"_assertNotInstantiated\",\n    value: function _assertNotInstantiated(methodName, methodDescription) {\n      if (this._instantiated) {\n        throw new Error(\"Cannot \".concat(methodDescription, \" when the test module has already been instantiated. \") + \"Make sure you are not using `inject` before `\".concat(methodName, \"`.\"));\n      }\n    }\n  }, {\n    key: \"inject\",\n    value: function inject(token, notFoundValue, flags) {\n      this._initIfNeeded();\n\n      if (token === TestBed) {\n        return this;\n      } // Tests can inject things from the ng module and from the compiler,\n      // but the ng module can't inject things from the compiler and vice versa.\n\n\n      var UNDEFINED = {};\n\n      var result = this._moduleRef.injector.get(token, UNDEFINED, flags);\n\n      return result === UNDEFINED ? this._compiler.injector.get(token, notFoundValue, flags) : result;\n    }\n    /** @deprecated from v9.0.0 use TestBed.inject */\n\n  }, {\n    key: \"get\",\n    value: function get(token) {\n      var notFoundValue = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : Injector.THROW_IF_NOT_FOUND;\n      var flags = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : InjectFlags.Default;\n      return this.inject(token, notFoundValue, flags);\n    }\n  }, {\n    key: \"execute\",\n    value: function execute(tokens, fn, context) {\n      var _this23 = this;\n\n      this._initIfNeeded();\n\n      var params = tokens.map(function (t) {\n        return _this23.inject(t);\n      });\n      return fn.apply(context, params);\n    }\n  }, {\n    key: \"overrideModule\",\n    value: function overrideModule(ngModule, override) {\n      this._assertNotInstantiated('overrideModule', 'override module metadata');\n\n      this._moduleOverrides.push([ngModule, override]);\n    }\n  }, {\n    key: \"overrideComponent\",\n    value: function overrideComponent(component, override) {\n      this._assertNotInstantiated('overrideComponent', 'override component metadata');\n\n      this._componentOverrides.push([component, override]);\n    }\n  }, {\n    key: \"overrideDirective\",\n    value: function overrideDirective(directive, override) {\n      this._assertNotInstantiated('overrideDirective', 'override directive metadata');\n\n      this._directiveOverrides.push([directive, override]);\n    }\n  }, {\n    key: \"overridePipe\",\n    value: function overridePipe(pipe, override) {\n      this._assertNotInstantiated('overridePipe', 'override pipe metadata');\n\n      this._pipeOverrides.push([pipe, override]);\n    }\n  }, {\n    key: \"overrideProvider\",\n    value: function overrideProvider(token, provider) {\n      this._assertNotInstantiated('overrideProvider', 'override provider');\n\n      this.overrideProviderImpl(token, provider);\n    }\n  }, {\n    key: \"overrideProviderImpl\",\n    value: function overrideProviderImpl(token, provider) {\n      var deprecated = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : false;\n      var def = null;\n\n      if (typeof token !== 'string' && (def = ɵgetInjectableDef(token)) && def.providedIn === 'root') {\n        if (provider.useFactory) {\n          this._rootProviderOverrides.push({\n            provide: token,\n            useFactory: provider.useFactory,\n            deps: provider.deps || []\n          });\n        } else {\n          this._rootProviderOverrides.push({\n            provide: token,\n            useValue: provider.useValue\n          });\n        }\n      }\n\n      var flags = 0;\n      var value;\n\n      if (provider.useFactory) {\n        flags |= 1024\n        /* TypeFactoryProvider */\n        ;\n        value = provider.useFactory;\n      } else {\n        flags |= 256\n        /* TypeValueProvider */\n        ;\n        value = provider.useValue;\n      }\n\n      var deps = (provider.deps || []).map(function (dep) {\n        var depFlags = 0\n        /* None */\n        ;\n        var depToken;\n\n        if (Array.isArray(dep)) {\n          dep.forEach(function (entry) {\n            if (entry instanceof Optional) {\n              depFlags |= 2\n              /* Optional */\n              ;\n            } else if (entry instanceof SkipSelf) {\n              depFlags |= 1\n              /* SkipSelf */\n              ;\n            } else {\n              depToken = entry;\n            }\n          });\n        } else {\n          depToken = dep;\n        }\n\n        return [depFlags, depToken];\n      });\n      ɵoverrideProvider({\n        token: token,\n        flags: flags,\n        deps: deps,\n        value: value,\n        deprecatedBehavior: deprecated\n      });\n    }\n  }, {\n    key: \"overrideTemplateUsingTestingModule\",\n    value: function overrideTemplateUsingTestingModule(component, template) {\n      this._assertNotInstantiated('overrideTemplateUsingTestingModule', 'override template');\n\n      var OverrideComponent = function OverrideComponent() {\n        _classCallCheck(this, OverrideComponent);\n      };\n\n      OverrideComponent.decorators = [{\n        type: Component,\n        args: [{\n          selector: 'empty',\n          template: template,\n          jit: true\n        }]\n      }];\n\n      this._templateOverrides.push({\n        component: component,\n        templateOf: OverrideComponent\n      });\n    }\n  }, {\n    key: \"createComponent\",\n    value: function createComponent(component) {\n      var _this24 = this;\n\n      this._initIfNeeded();\n\n      var componentFactory = this._compiler.getComponentFactory(component);\n\n      if (!componentFactory) {\n        throw new Error(\"Cannot create the component \".concat(ɵstringify(component), \" as it was not imported into the testing module!\"));\n      } // TODO: Don't cast as `InjectionToken<boolean>`, declared type is boolean[]\n\n\n      var noNgZone = this.inject(ComponentFixtureNoNgZone, false); // TODO: Don't cast as `InjectionToken<boolean>`, declared type is boolean[]\n\n      var autoDetect = this.inject(ComponentFixtureAutoDetect, false);\n      var ngZone = noNgZone ? null : this.inject(NgZone, null);\n      var testComponentRenderer = this.inject(TestComponentRenderer);\n      var rootElId = \"root\".concat(_nextRootElementId$1++);\n      testComponentRenderer.insertRootElement(rootElId);\n\n      var initComponent = function initComponent() {\n        var componentRef = componentFactory.create(Injector.NULL, [], \"#\".concat(rootElId), _this24._moduleRef);\n        return new ComponentFixture(componentRef, ngZone, autoDetect);\n      };\n\n      var fixture = !ngZone ? initComponent() : ngZone.run(initComponent);\n\n      this._activeFixtures.push(fixture);\n\n      return fixture;\n    }\n  }, {\n    key: \"destroyActiveFixtures\",\n    value: function destroyActiveFixtures() {\n      var errorCount = 0;\n\n      this._activeFixtures.forEach(function (fixture) {\n        try {\n          fixture.destroy();\n        } catch (e) {\n          errorCount++;\n          console.error('Error during cleanup of component', {\n            component: fixture.componentInstance,\n            stacktrace: e\n          });\n        }\n      });\n\n      this._activeFixtures = [];\n\n      if (errorCount > 0 && this.shouldRethrowTeardownErrors()) {\n        throw Error(\"\".concat(errorCount, \" \").concat(errorCount === 1 ? 'component' : 'components', \" \") + \"threw errors during cleanup\");\n      }\n    }\n  }, {\n    key: \"shouldRethrowTeardownErrors\",\n    value: function shouldRethrowTeardownErrors() {\n      var _a, _b;\n\n      var instanceOptions = this._instanceTeardownOptions;\n      var environmentOptions = TestBedViewEngine._environmentTeardownOptions; // If the new teardown behavior hasn't been configured, preserve the old behavior.\n\n      if (!instanceOptions && !environmentOptions) {\n        return false;\n      } // Otherwise use the configured behavior or default to rethrowing.\n\n\n      return (_b = (_a = instanceOptions === null || instanceOptions === void 0 ? void 0 : instanceOptions.rethrowErrors) !== null && _a !== void 0 ? _a : environmentOptions === null || environmentOptions === void 0 ? void 0 : environmentOptions.rethrowErrors) !== null && _b !== void 0 ? _b : true;\n    }\n  }, {\n    key: \"shouldTearDownTestingModule\",\n    value: function shouldTearDownTestingModule() {\n      var _a, _b, _c, _d;\n\n      return (_d = (_b = (_a = this._instanceTeardownOptions) === null || _a === void 0 ? void 0 : _a.destroyAfterEach) !== null && _b !== void 0 ? _b : (_c = TestBedViewEngine._environmentTeardownOptions) === null || _c === void 0 ? void 0 : _c.destroyAfterEach) !== null && _d !== void 0 ? _d : TEARDOWN_TESTING_MODULE_ON_DESTROY_DEFAULT;\n    }\n  }, {\n    key: \"tearDownTestingModule\",\n    value: function tearDownTestingModule() {\n      var _a, _b, _c, _d, _e; // If the module ref has already been destroyed, we won't be able to get a test renderer.\n\n\n      if (this._moduleRef === null) {\n        return;\n      } // Resolve the renderer ahead of time, because we want to remove the root elements as the very\n      // last step, but the injector will be destroyed as a part of the module ref destruction.\n\n\n      var testRenderer = this.inject(TestComponentRenderer);\n\n      try {\n        this._moduleRef.destroy();\n      } catch (e) {\n        if ((_d = (_b = (_a = this._instanceTeardownOptions) === null || _a === void 0 ? void 0 : _a.rethrowErrors) !== null && _b !== void 0 ? _b : (_c = TestBedViewEngine._environmentTeardownOptions) === null || _c === void 0 ? void 0 : _c.rethrowErrors) !== null && _d !== void 0 ? _d : true) {\n          throw e;\n        } else {\n          console.error('Error during cleanup of a testing module', {\n            component: this._moduleRef.instance,\n            stacktrace: e\n          });\n        }\n      } finally {\n        (_e = testRenderer === null || testRenderer === void 0 ? void 0 : testRenderer.removeAllRootElements) === null || _e === void 0 ? void 0 : _e.call(testRenderer);\n      }\n    }\n  }], [{\n    key: \"initTestEnvironment\",\n    value: function initTestEnvironment(ngModule, platform, summariesOrOptions) {\n      var testBed = _getTestBedViewEngine();\n\n      testBed.initTestEnvironment(ngModule, platform, summariesOrOptions);\n      return testBed;\n    }\n    /**\n     * Reset the providers for the test injector.\n     */\n\n  }, {\n    key: \"resetTestEnvironment\",\n    value: function resetTestEnvironment() {\n      _getTestBedViewEngine().resetTestEnvironment();\n    }\n  }, {\n    key: \"resetTestingModule\",\n    value: function resetTestingModule() {\n      _getTestBedViewEngine().resetTestingModule();\n\n      return TestBedViewEngine;\n    }\n    /**\n     * Allows overriding default compiler providers and settings\n     * which are defined in test_injector.js\n     */\n\n  }, {\n    key: \"configureCompiler\",\n    value: function configureCompiler(config) {\n      _getTestBedViewEngine().configureCompiler(config);\n\n      return TestBedViewEngine;\n    }\n    /**\n     * Allows overriding default providers, directives, pipes, modules of the test injector,\n     * which are defined in test_injector.js\n     */\n\n  }, {\n    key: \"configureTestingModule\",\n    value: function configureTestingModule(moduleDef) {\n      _getTestBedViewEngine().configureTestingModule(moduleDef);\n\n      return TestBedViewEngine;\n    }\n    /**\n     * Compile components with a `templateUrl` for the test's NgModule.\n     * It is necessary to call this function\n     * as fetching urls is asynchronous.\n     */\n\n  }, {\n    key: \"compileComponents\",\n    value: function compileComponents() {\n      return getTestBed().compileComponents();\n    }\n  }, {\n    key: \"overrideModule\",\n    value: function overrideModule(ngModule, override) {\n      _getTestBedViewEngine().overrideModule(ngModule, override);\n\n      return TestBedViewEngine;\n    }\n  }, {\n    key: \"overrideComponent\",\n    value: function overrideComponent(component, override) {\n      _getTestBedViewEngine().overrideComponent(component, override);\n\n      return TestBedViewEngine;\n    }\n  }, {\n    key: \"overrideDirective\",\n    value: function overrideDirective(directive, override) {\n      _getTestBedViewEngine().overrideDirective(directive, override);\n\n      return TestBedViewEngine;\n    }\n  }, {\n    key: \"overridePipe\",\n    value: function overridePipe(pipe, override) {\n      _getTestBedViewEngine().overridePipe(pipe, override);\n\n      return TestBedViewEngine;\n    }\n  }, {\n    key: \"overrideTemplate\",\n    value: function overrideTemplate(component, template) {\n      _getTestBedViewEngine().overrideComponent(component, {\n        set: {\n          template: template,\n          templateUrl: null\n        }\n      });\n\n      return TestBedViewEngine;\n    }\n    /**\n     * Overrides the template of the given component, compiling the template\n     * in the context of the TestingModule.\n     *\n     * Note: This works for JIT and AOTed components as well.\n     */\n\n  }, {\n    key: \"overrideTemplateUsingTestingModule\",\n    value: function overrideTemplateUsingTestingModule(component, template) {\n      _getTestBedViewEngine().overrideTemplateUsingTestingModule(component, template);\n\n      return TestBedViewEngine;\n    }\n  }, {\n    key: \"overrideProvider\",\n    value: function overrideProvider(token, provider) {\n      _getTestBedViewEngine().overrideProvider(token, provider);\n\n      return TestBedViewEngine;\n    }\n  }, {\n    key: \"inject\",\n    value: function inject(token, notFoundValue, flags) {\n      return _getTestBedViewEngine().inject(token, notFoundValue, flags);\n    }\n    /** @deprecated from v9.0.0 use TestBed.inject */\n\n  }, {\n    key: \"get\",\n    value: function get(token) {\n      var notFoundValue = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : Injector.THROW_IF_NOT_FOUND;\n      var flags = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : InjectFlags.Default;\n      return _getTestBedViewEngine().inject(token, notFoundValue, flags);\n    }\n  }, {\n    key: \"createComponent\",\n    value: function createComponent(component) {\n      return _getTestBedViewEngine().createComponent(component);\n    }\n  }, {\n    key: \"shouldTearDownTestingModule\",\n    value: function shouldTearDownTestingModule() {\n      return _getTestBedViewEngine().shouldTearDownTestingModule();\n    }\n  }, {\n    key: \"tearDownTestingModule\",\n    value: function tearDownTestingModule() {\n      _getTestBedViewEngine().tearDownTestingModule();\n    }\n  }]);\n\n  return TestBedViewEngine;\n}();\n/**\n * @description\n * Configures and initializes environment for unit testing and provides methods for\n * creating components and services in unit tests.\n *\n * `TestBed` is the primary api for writing unit tests for Angular applications and libraries.\n *\n * Note: Use `TestBed` in tests. It will be set to either `TestBedViewEngine` or `TestBedRender3`\n * according to the compiler used.\n *\n * @publicApi\n */\n\n\nvar TestBed = ɵivyEnabled ? TestBedRender3 : TestBedViewEngine;\n/**\n * Returns a singleton of the applicable `TestBed`.\n *\n * It will be either an instance of `TestBedViewEngine` or `TestBedRender3`.\n *\n * @publicApi\n */\n\nvar getTestBed = ɵivyEnabled ? _getTestBedRender3 : _getTestBedViewEngine;\nvar testBed$1;\n\nfunction _getTestBedViewEngine() {\n  return testBed$1 = testBed$1 || new TestBedViewEngine();\n}\n/**\n * Allows injecting dependencies in `beforeEach()` and `it()`.\n *\n * Example:\n *\n * ```\n * beforeEach(inject([Dependency, AClass], (dep, object) => {\n *   // some code that uses `dep` and `object`\n *   // ...\n * }));\n *\n * it('...', inject([AClass], (object) => {\n *   object.doSomething();\n *   expect(...);\n * })\n * ```\n *\n * @publicApi\n */\n\n\nfunction _inject(tokens, fn) {\n  var testBed = getTestBed(); // Not using an arrow function to preserve context passed from call site\n\n  return function () {\n    return testBed.execute(tokens, fn, this);\n  };\n}\n/**\n * @publicApi\n */\n\n\nvar InjectSetupWrapper = /*#__PURE__*/function () {\n  function InjectSetupWrapper(_moduleDef) {\n    _classCallCheck(this, InjectSetupWrapper);\n\n    this._moduleDef = _moduleDef;\n  }\n\n  _createClass(InjectSetupWrapper, [{\n    key: \"_addModule\",\n    value: function _addModule() {\n      var moduleDef = this._moduleDef();\n\n      if (moduleDef) {\n        getTestBed().configureTestingModule(moduleDef);\n      }\n    }\n  }, {\n    key: \"inject\",\n    value: function inject(tokens, fn) {\n      var self = this; // Not using an arrow function to preserve context passed from call site\n\n      return function () {\n        self._addModule();\n\n        return _inject(tokens, fn).call(this);\n      };\n    }\n  }]);\n\n  return InjectSetupWrapper;\n}();\n\nfunction withModule(moduleDef, fn) {\n  if (fn) {\n    // Not using an arrow function to preserve context passed from call site\n    return function () {\n      var testBed = getTestBed();\n\n      if (moduleDef) {\n        testBed.configureTestingModule(moduleDef);\n      }\n\n      return fn.apply(this);\n    };\n  }\n\n  return new InjectSetupWrapper(function () {\n    return moduleDef;\n  });\n}\n/**\n * @license\n * Copyright Google LLC All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.io/license\n */\n\n\nvar _global = typeof window === 'undefined' ? global : window; // Reset the test providers and the fake async zone before each test.\n\n\nif (_global.beforeEach) {\n  _global.beforeEach(getCleanupHook(false));\n} // We provide both a `beforeEach` and `afterEach`, because the updated behavior for\n// tearing down the module is supposed to run after the test so that we can associate\n// teardown errors with the correct test.\n\n\nif (_global.afterEach) {\n  _global.afterEach(getCleanupHook(true));\n}\n\nfunction getCleanupHook(expectedTeardownValue) {\n  return function () {\n    if (TestBed.shouldTearDownTestingModule() === expectedTeardownValue) {\n      TestBed.resetTestingModule();\n      resetFakeAsyncZone();\n    }\n  };\n}\n/**\n * This API should be removed. But doing so seems to break `google3` and so it requires a bit of\n * investigation.\n *\n * A work around is to mark it as `@codeGenApi` for now and investigate later.\n *\n * @codeGenApi\n */\n// TODO(iminar): Remove this code in a safe way.\n\n\nvar __core_private_testing_placeholder__ = '';\n/**\n * @license\n * Copyright Google LLC All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.io/license\n */\n\n/**\n * @license\n * Copyright Google LLC All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.io/license\n */\n\n/**\n * @license\n * Copyright Google LLC All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.io/license\n */\n\n/**\n * @license\n * Copyright Google LLC All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.io/license\n */\n// This file only reexports content of the `src` folder. Keep it that way.\n\n/**\n * @license\n * Copyright Google LLC All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.io/license\n */\n\n/**\n * Generated bundle index. Do not edit.\n */\n\nexport { ComponentFixture, ComponentFixtureAutoDetect, ComponentFixtureNoNgZone, InjectSetupWrapper, TestBed, TestComponentRenderer, __core_private_testing_placeholder__, async, discardPeriodicTasks, fakeAsync, flush, flushMicrotasks, getTestBed, _inject as inject, resetFakeAsyncZone, tick, waitForAsync, withModule, MetadataOverrider as ɵMetadataOverrider, TestingCompiler as ɵTestingCompiler, TestingCompilerFactory as ɵTestingCompilerFactory, TestBedViewEngine as ɵangular_packages_core_testing_testing_a, TestBedRender3 as ɵangular_packages_core_testing_testing_b, _getTestBedRender3 as ɵangular_packages_core_testing_testing_c }; //# sourceMappingURL=testing.js.map","map":{"version":3,"sources":["C:/projects/custom/angular11_12_table/node_modules/@angular/core/fesm2015/testing.js"],"names":["getDebugNode","RendererFactory2","ɵstringify","ɵReflectionCapabilities","Directive","Component","Pipe","NgModule","ɵgetInjectableDef","resolveForwardRef","ɵNG_COMP_DEF","ɵRender3NgModuleRef","ApplicationInitStatus","LOCALE_ID","ɵDEFAULT_LOCALE_ID","ɵsetLocaleId","ɵRender3ComponentFactory","ɵcompileComponent","ɵNG_DIR_DEF","ɵcompileDirective","ɵNG_PIPE_DEF","ɵcompilePipe","ɵNG_MOD_DEF","ɵtransitiveScopesFor","ɵpatchComponentDefWithScope","ɵNG_INJ_DEF","ɵcompileNgModuleDefs","NgZone","Compiler","COMPILER_OPTIONS","ɵNgModuleFactory","ModuleWithComponentFactories","InjectionToken","Injector","InjectFlags","ɵresetCompiledComponents","ɵflushModuleScopingQueueAsMuchAsPossible","Injectable","ɵclearOverrides","ɵoverrideComponentView","ɵINJECTOR_SCOPE","Optional","SkipSelf","ɵoverrideProvider","ɵivyEnabled","__awaiter","ResourceLoader","ɵngcc0","waitForAsync","fn","_Zone","Zone","Promise","reject","asyncTest","__symbol__","async","ComponentFixture","componentRef","ngZone","_autoDetect","_isStable","_isDestroyed","_resolve","_promise","_onUnstableSubscription","_onStableSubscription","_onMicrotaskEmptySubscription","_onErrorSubscription","changeDetectorRef","elementRef","location","debugElement","nativeElement","componentInstance","instance","runOutsideAngular","onUnstable","subscribe","next","onMicrotaskEmpty","detectChanges","onStable","scheduleMicroTask","hasPendingMacrotasks","onError","error","checkNoChanges","run","_tick","autoDetect","Error","isStable","resolve","res","_renderer","undefined","injector","get","renderer","_getRenderer","whenRenderingDone","whenStable","destroy","unsubscribe","current","fakeAsyncTestModule","fakeAsyncTestModuleNotLoadedErrorMessage","resetFakeAsyncZone","fakeAsync","tick","millis","tickOptions","processNewMacroTasksSynchronously","flush","maxTurns","discardPeriodicTasks","flushMicrotasks","resolveComponentResources","resourceResolver","componentResolved","urlMap","Map","cachedResourceResolve","url","promise","resp","set","then","unwrapResponse","componentResourceResolutionQueue","forEach","component","type","promises","templateUrl","push","template","styleUrls","styles","styleOffset","length","styleUrl","index","style","splice","indexOf","fullyResolved","all","componentDefResolved","clearResolutionOfComponentResourcesQueue","componentDefPendingResolution","Set","maybeQueueResolutionOfComponentResources","metadata","componentNeedsResolution","add","isComponentDefPendingResolution","has","hasOwnProperty","old","restoreComponentResolutionQueue","queue","clear","_","isComponentResourceResolutionQueueEmpty","size","response","text","delete","_nextReferenceId","MetadataOverrider","_references","metadataClass","oldMetadata","override","props","_valueProps","prop","remove","setMetadata","removeMetadata","addMetadata","references","removeObjects","removeValue","Array","isArray","value","_propHashKey","propValue","filter","addValue","concat","propName","replacer","key","_serializeReference","JSON","stringify","ref","id","obj","Object","keys","startsWith","proto","getPrototypeOf","protoProp","desc","getOwnPropertyDescriptor","reflection","OverrideResolver","overrides","resolved","addOverride","annotations","i","annotation","isKnownType","getAnnotation","overrider","overrideMetadata","DirectiveResolver","ComponentResolver","PipeResolver","NgModuleResolver","TestingModuleOverride","isTestingModuleOverride","DECLARATION","OVERRIDE_TEMPLATE","R3TestBedCompiler","platform","additionalModuleTypes","originalComponentResolutionQueue","declarations","imports","providers","schemas","pendingComponents","pendingDirectives","pendingPipes","seenComponents","seenDirectives","overriddenModules","existingComponentStyles","resolvers","initResolvers","componentToModuleScope","initialNgDefs","defCleanupOps","_injector","compilerProviders","providerOverrides","rootProviderOverrides","providerOverridesByModule","providerOverridesByToken","moduleProvidersOverridden","testModuleRef","DynamicTestModule","testModuleType","moduleDef","queueTypeArray","queueTypesFromModulesArray","ngModule","module","invalidTypeError","name","recompileNgModule","directive","pipe","token","provider","providerDef","useFactory","provide","deps","multi","useValue","injectableDef","providedIn","overridesBucket","existingOverrides","def","hasStyleUrls","overrideStyleUrls","overrideComponent","clearComponentResolutionQueue","needsAsyncResources","compileTypesSync","resolver","resourceLoader","compileTestModule","applyTransitiveScopes","applyProviderOverrides","patchComponentsWithExistingStyles","parentInjector","runInitializers","localeId","moduleType","applyProviderOverridesToModule","compileComponents","maybeUnwrapFn","ɵmod","reduce","factories","declaration","componentDef","ɵcmp","maybeStoreNgDef","testingModuleDef","affectedModules","collectModulesAffectedByOverrides","storeFieldOfDefOnType","transitiveCompileScopes","moduleToScope","getScopeOfModule","isTestingModule","realType","componentType","moduleScope","maybeApplyOverrides","field","hasProviderOverrides","patchDefWithProviderOverrides","injectorDef","getOverriddenProviders","importedModule","flatten","isModuleWithProviders","object","fieldName","originalValue","arr","queueType","processedNgModuleDefs","queueTypesFromModulesArrayRecur","hasNgModuleDef","exports","seenModules","calcAffectedModulesRecur","path","item","currentDef","defField","forEachRight","op","descriptor","defineProperty","RootScopeModule","enableLongStackTrace","R3TestCompiler","compilerOptions","opts","CompilerModule","CompilerModuleFactory","create","getProviderToken","getSingleProviderOverrides","flattenedProviders","getProviderOverrides","overriddenProviders","final","seenOverriddenProviders","unshift","assign","providersResolver","processProvidersFn","ngDef","maybeFn","Function","values","mapFn","out","getProviderField","idx","expectedType","testBed","_compileNgModuleSync","_compileNgModuleAsync","ngModuleFactory","compileModuleSync","componentFactories","_getComponentFactories","compileModuleAsync","meta","_getModuleResolver","TEARDOWN_TESTING_MODULE_ON_DESTROY_DEFAULT","TestComponentRenderer","rootElementId","ComponentFixtureAutoDetect","ComponentFixtureNoNgZone","_nextRootElementId","TestBedRender3","_compiler","_testModuleRef","_activeFixtures","_globalCompilationChecked","summariesOrOptions","_environmentTeardownOptions","teardown","resetTestingModule","checkGlobalCompilationFinished","compiler","restoreOriginalState","destroyActiveFixtures","shouldTearDownTestingModule","tearDownTestingModule","_instanceTeardownOptions","config","useJit","setCompilerProviders","assertNotInstantiated","configureTestingModule","notFoundValue","flags","UNDEFINED","result","THROW_IF_NOT_FOUND","Default","inject","tokens","context","params","map","t","apply","overrideModule","overrideTemplateUsingTestingModule","overrideDirective","overridePipe","overrideProvider","testComponentRenderer","rootElId","insertRootElement","noNgZone","componentFactory","initComponent","NULL","fixture","finalize","methodName","methodDescription","errorCount","e","console","stacktrace","shouldRethrowTeardownErrors","_a","_b","instanceOptions","environmentOptions","rethrowErrors","_c","_d","destroyAfterEach","testRenderer","removeAllRootElements","call","_getTestBedRender3","initTestEnvironment","resetTestEnvironment","configureCompiler","createComponent","unimplemented","TestingCompiler","summaries","ɵfac","ɵTestingCompiler_BaseFactory","TestingCompiler_Factory","ɵɵgetInheritedFactory","ɵprov","ɵɵdefineInjectable","factory","ngDevMode","ɵsetClassMetadata","TestingCompilerFactory","_nextRootElementId$1","TestBedViewEngine","_instantiated","_moduleRef","_moduleFactory","_pendingModuleFactory","_compilerOptions","_moduleOverrides","_componentOverrides","_directiveOverrides","_pipeOverrides","_providers","_declarations","_imports","_schemas","_testEnvAotSummaries","_aotSummaries","_templateOverrides","_isRoot","_rootProviderOverrides","aotSummaries","_assertNotInstantiated","_createCompilerAndModule","compileModuleAndAllComponentsAsync","compileModuleAndAllComponentsSync","errorCompType","getComponentFromError","templateOf","compFactory","getComponentFactory","shouldCoalesceEventChangeDetection","ngZoneInjector","parent","TestBed","entry","rootScopeImports","decorators","args","jit","compilerFactory","createTestingCompiler","summary","loadAotSummaries","_initIfNeeded","overrideProviderImpl","deprecated","dep","depFlags","depToken","deprecatedBehavior","OverrideComponent","selector","_e","_getTestBedViewEngine","getTestBed","testBed$1","execute","InjectSetupWrapper","_moduleDef","self","_addModule","withModule","_global","window","global","beforeEach","getCleanupHook","afterEach","expectedTeardownValue","__core_private_testing_placeholder__","ɵMetadataOverrider","ɵTestingCompiler","ɵTestingCompilerFactory","ɵangular_packages_core_testing_testing_a","ɵangular_packages_core_testing_testing_b","ɵangular_packages_core_testing_testing_c"],"mappings":"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EAAuB;AACnB,MAAIyD,mBAAJ,EAAyB;AACrB,WAAOA,mBAAmB,CAACG,SAApB,CAA8B5D,EAA9B,CAAP;AACH;;AACD,QAAM,IAAI0C,KAAJ,CAAUgB,wCAAV,CAAN;AACH;AACD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;AACA,SAASG,IAAT,GAEG;AAAA,MAFWC,MAEX,uEAFoB,CAEpB;AAAA,MAFuBC,WAEvB,uEAFqC;AACpCC,IAAAA,iCAAiC,EAAE;AADC,GAErC;;AACC,MAAIP,mBAAJ,EAAyB;AACrB,WAAOA,mBAAmB,CAACI,IAApB,CAAyBC,MAAzB,EAAiCC,WAAjC,CAAP;AACH;;AACD,QAAM,IAAIrB,KAAJ,CAAUgB,wCAAV,CAAN;AACH;AACD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;AACA,SAASO,KAAT,CAAeC,QAAf,EAAyB;AACrB,MAAIT,mBAAJ,EAAyB;AACrB,WAAOA,mBAAmB,CAACQ,KAApB,CAA0BC,QAA1B,CAAP;AACH;;AACD,QAAM,IAAIxB,KAAJ,CAAUgB,wCAAV,CAAN;AACH;AACD;AACA;AACA;AACA;AACA;;;AACA,SAASS,oBAAT,GAAgC;AAC5B,MAAIV,mBAAJ,EAAyB;AACrB,WAAOA,mBAAmB,CAACU,oBAApB,EAAP;AACH;;AACD,QAAM,IAAIzB,KAAJ,CAAUgB,wCAAV,CAAN;AACH;AACD;AACA;AACA;AACA;AACA;;;AACA,SAASU,eAAT,GAA2B;AACvB,MAAIX,mBAAJ,EAAyB;AACrB,WAAOA,mBAAmB,CAACW,eAApB,EAAP;AACH;;AACD,QAAM,IA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","sourcesContent":["/**\n * @license Angular v12.1.4\n * (c) 2010-2021 Google LLC. https://angular.io/\n * License: MIT\n */\n\nimport { getDebugNode, RendererFactory2, ɵstringify, ɵReflectionCapabilities, Directive, Component, Pipe, NgModule, ɵgetInjectableDef, resolveForwardRef, ɵNG_COMP_DEF, ɵRender3NgModuleRef, ApplicationInitStatus, LOCALE_ID, ɵDEFAULT_LOCALE_ID, ɵsetLocaleId, ɵRender3ComponentFactory, ɵcompileComponent, ɵNG_DIR_DEF, ɵcompileDirective, ɵNG_PIPE_DEF, ɵcompilePipe, ɵNG_MOD_DEF, ɵtransitiveScopesFor, ɵpatchComponentDefWithScope, ɵNG_INJ_DEF, ɵcompileNgModuleDefs, NgZone, Compiler, COMPILER_OPTIONS, ɵNgModuleFactory, ModuleWithComponentFactories, InjectionToken, Injector, InjectFlags, ɵresetCompiledComponents, ɵflushModuleScopingQueueAsMuchAsPossible, Injectable, ɵclearOverrides, ɵoverrideComponentView, ɵINJECTOR_SCOPE, Optional, SkipSelf, ɵoverrideProvider, ɵivyEnabled } from '@angular/core';\nimport { __awaiter } from 'tslib';\nimport { ResourceLoader } from '@angular/compiler';\n\n/**\n * @license\n * Copyright Google LLC All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.io/license\n */\n/**\n * Wraps a test function in an asynchronous test zone. The test will automatically\n * complete when all asynchronous calls within this zone are done. Can be used\n * to wrap an {@link inject} call.\n *\n * Example:\n *\n * ```\n * it('...', waitForAsync(inject([AClass], (object) => {\n *   object.doSomething.then(() => {\n *     expect(...);\n *   })\n * });\n * ```\n *\n * @publicApi\n */\nimport * as ɵngcc0 from '@angular/core';\nfunction waitForAsync(fn) {\n    const _Zone = typeof Zone !== 'undefined' ? Zone : null;\n    if (!_Zone) {\n        return function () {\n            return Promise.reject('Zone is needed for the waitForAsync() test helper but could not be found. ' +\n                'Please make sure that your environment includes zone.js');\n        };\n    }\n    const asyncTest = _Zone && _Zone[_Zone.__symbol__('asyncTest')];\n    if (typeof asyncTest === 'function') {\n        return asyncTest(fn);\n    }\n    return function () {\n        return Promise.reject('zone-testing.js is needed for the async() test helper but could not be found. ' +\n            'Please make sure that your environment includes zone.js/testing');\n    };\n}\n/**\n * @deprecated use `waitForAsync()`, (expected removal in v12)\n * @see {@link waitForAsync}\n * @publicApi\n * */\nfunction async(fn) {\n    return waitForAsync(fn);\n}\n\n/**\n * @license\n * Copyright Google LLC All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.io/license\n */\n/**\n * Fixture for debugging and testing a component.\n *\n * @publicApi\n */\nclass ComponentFixture {\n    constructor(componentRef, ngZone, _autoDetect) {\n        this.componentRef = componentRef;\n        this.ngZone = ngZone;\n        this._autoDetect = _autoDetect;\n        this._isStable = true;\n        this._isDestroyed = false;\n        this._resolve = null;\n        this._promise = null;\n        this._onUnstableSubscription = null;\n        this._onStableSubscription = null;\n        this._onMicrotaskEmptySubscription = null;\n        this._onErrorSubscription = null;\n        this.changeDetectorRef = componentRef.changeDetectorRef;\n        this.elementRef = componentRef.location;\n        this.debugElement = getDebugNode(this.elementRef.nativeElement);\n        this.componentInstance = componentRef.instance;\n        this.nativeElement = this.elementRef.nativeElement;\n        this.componentRef = componentRef;\n        this.ngZone = ngZone;\n        if (ngZone) {\n            // Create subscriptions outside the NgZone so that the callbacks run oustide\n            // of NgZone.\n            ngZone.runOutsideAngular(() => {\n                this._onUnstableSubscription = ngZone.onUnstable.subscribe({\n                    next: () => {\n                        this._isStable = false;\n                    }\n                });\n                this._onMicrotaskEmptySubscription = ngZone.onMicrotaskEmpty.subscribe({\n                    next: () => {\n                        if (this._autoDetect) {\n                            // Do a change detection run with checkNoChanges set to true to check\n                            // there are no changes on the second run.\n                            this.detectChanges(true);\n                        }\n                    }\n                });\n                this._onStableSubscription = ngZone.onStable.subscribe({\n                    next: () => {\n                        this._isStable = true;\n                        // Check whether there is a pending whenStable() completer to resolve.\n                        if (this._promise !== null) {\n                            // If so check whether there are no pending macrotasks before resolving.\n                            // Do this check in the next tick so that ngZone gets a chance to update the state of\n                            // pending macrotasks.\n                            scheduleMicroTask(() => {\n                                if (!ngZone.hasPendingMacrotasks) {\n                                    if (this._promise !== null) {\n                                        this._resolve(true);\n                                        this._resolve = null;\n                                        this._promise = null;\n                                    }\n                                }\n                            });\n                        }\n                    }\n                });\n                this._onErrorSubscription = ngZone.onError.subscribe({\n                    next: (error) => {\n                        throw error;\n                    }\n                });\n            });\n        }\n    }\n    _tick(checkNoChanges) {\n        this.changeDetectorRef.detectChanges();\n        if (checkNoChanges) {\n            this.checkNoChanges();\n        }\n    }\n    /**\n     * Trigger a change detection cycle for the component.\n     */\n    detectChanges(checkNoChanges = true) {\n        if (this.ngZone != null) {\n            // Run the change detection inside the NgZone so that any async tasks as part of the change\n            // detection are captured by the zone and can be waited for in isStable.\n            this.ngZone.run(() => {\n                this._tick(checkNoChanges);\n            });\n        }\n        else {\n            // Running without zone. Just do the change detection.\n            this._tick(checkNoChanges);\n        }\n    }\n    /**\n     * Do a change detection run to make sure there were no changes.\n     */\n    checkNoChanges() {\n        this.changeDetectorRef.checkNoChanges();\n    }\n    /**\n     * Set whether the fixture should autodetect changes.\n     *\n     * Also runs detectChanges once so that any existing change is detected.\n     */\n    autoDetectChanges(autoDetect = true) {\n        if (this.ngZone == null) {\n            throw new Error('Cannot call autoDetectChanges when ComponentFixtureNoNgZone is set');\n        }\n        this._autoDetect = autoDetect;\n        this.detectChanges();\n    }\n    /**\n     * Return whether the fixture is currently stable or has async tasks that have not been completed\n     * yet.\n     */\n    isStable() {\n        return this._isStable && !this.ngZone.hasPendingMacrotasks;\n    }\n    /**\n     * Get a promise that resolves when the fixture is stable.\n     *\n     * This can be used to resume testing after events have triggered asynchronous activity or\n     * asynchronous change detection.\n     */\n    whenStable() {\n        if (this.isStable()) {\n            return Promise.resolve(false);\n        }\n        else if (this._promise !== null) {\n            return this._promise;\n        }\n        else {\n            this._promise = new Promise(res => {\n                this._resolve = res;\n            });\n            return this._promise;\n        }\n    }\n    _getRenderer() {\n        if (this._renderer === undefined) {\n            this._renderer = this.componentRef.injector.get(RendererFactory2, null);\n        }\n        return this._renderer;\n    }\n    /**\n     * Get a promise that resolves when the ui state is stable following animations.\n     */\n    whenRenderingDone() {\n        const renderer = this._getRenderer();\n        if (renderer && renderer.whenRenderingDone) {\n            return renderer.whenRenderingDone();\n        }\n        return this.whenStable();\n    }\n    /**\n     * Trigger component destruction.\n     */\n    destroy() {\n        if (!this._isDestroyed) {\n            this.componentRef.destroy();\n            if (this._onUnstableSubscription != null) {\n                this._onUnstableSubscription.unsubscribe();\n                this._onUnstableSubscription = null;\n            }\n            if (this._onStableSubscription != null) {\n                this._onStableSubscription.unsubscribe();\n                this._onStableSubscription = null;\n            }\n            if (this._onMicrotaskEmptySubscription != null) {\n                this._onMicrotaskEmptySubscription.unsubscribe();\n                this._onMicrotaskEmptySubscription = null;\n            }\n            if (this._onErrorSubscription != null) {\n                this._onErrorSubscription.unsubscribe();\n                this._onErrorSubscription = null;\n            }\n            this._isDestroyed = true;\n        }\n    }\n}\nfunction scheduleMicroTask(fn) {\n    Zone.current.scheduleMicroTask('scheduleMicrotask', fn);\n}\n\n/**\n * @license\n * Copyright Google LLC All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.io/license\n */\nconst _Zone = typeof Zone !== 'undefined' ? Zone : null;\nconst fakeAsyncTestModule = _Zone && _Zone[_Zone.__symbol__('fakeAsyncTest')];\nconst fakeAsyncTestModuleNotLoadedErrorMessage = `zone-testing.js is needed for the fakeAsync() test helper but could not be found.\n        Please make sure that your environment includes zone.js/testing`;\n/**\n * Clears out the shared fake async zone for a test.\n * To be called in a global `beforeEach`.\n *\n * @publicApi\n */\nfunction resetFakeAsyncZone() {\n    if (fakeAsyncTestModule) {\n        return fakeAsyncTestModule.resetFakeAsyncZone();\n    }\n    throw new Error(fakeAsyncTestModuleNotLoadedErrorMessage);\n}\n/**\n * Wraps a function to be executed in the `fakeAsync` zone:\n * - Microtasks are manually executed by calling `flushMicrotasks()`.\n * - Timers are synchronous; `tick()` simulates the asynchronous passage of time.\n *\n * If there are any pending timers at the end of the function, an exception is thrown.\n *\n * Can be used to wrap `inject()` calls.\n *\n * @param fn The function that you want to wrap in the `fakeAysnc` zone.\n *\n * @usageNotes\n * ### Example\n *\n * {@example core/testing/ts/fake_async.ts region='basic'}\n *\n *\n * @returns The function wrapped to be executed in the `fakeAsync` zone.\n * Any arguments passed when calling this returned function will be passed through to the `fn`\n * function in the parameters when it is called.\n *\n * @publicApi\n */\nfunction fakeAsync(fn) {\n    if (fakeAsyncTestModule) {\n        return fakeAsyncTestModule.fakeAsync(fn);\n    }\n    throw new Error(fakeAsyncTestModuleNotLoadedErrorMessage);\n}\n/**\n * Simulates the asynchronous passage of time for the timers in the `fakeAsync` zone.\n *\n * The microtasks queue is drained at the very start of this function and after any timer callback\n * has been executed.\n *\n * @param millis The number of milliseconds to advance the virtual timer.\n * @param tickOptions The options to pass to the `tick()` function.\n *\n * @usageNotes\n *\n * The `tick()` option is a flag called `processNewMacroTasksSynchronously`,\n * which determines whether or not to invoke new macroTasks.\n *\n * If you provide a `tickOptions` object, but do not specify a\n * `processNewMacroTasksSynchronously` property (`tick(100, {})`),\n * then `processNewMacroTasksSynchronously` defaults to true.\n *\n * If you omit the `tickOptions` parameter (`tick(100))`), then\n * `tickOptions` defaults to `{processNewMacroTasksSynchronously: true}`.\n *\n * ### Example\n *\n * {@example core/testing/ts/fake_async.ts region='basic'}\n *\n * The following example includes a nested timeout (new macroTask), and\n * the `tickOptions` parameter is allowed to default. In this case,\n * `processNewMacroTasksSynchronously` defaults to true, and the nested\n * function is executed on each tick.\n *\n * ```\n * it ('test with nested setTimeout', fakeAsync(() => {\n *   let nestedTimeoutInvoked = false;\n *   function funcWithNestedTimeout() {\n *     setTimeout(() => {\n *       nestedTimeoutInvoked = true;\n *     });\n *   };\n *   setTimeout(funcWithNestedTimeout);\n *   tick();\n *   expect(nestedTimeoutInvoked).toBe(true);\n * }));\n * ```\n *\n * In the following case, `processNewMacroTasksSynchronously` is explicitly\n * set to false, so the nested timeout function is not invoked.\n *\n * ```\n * it ('test with nested setTimeout', fakeAsync(() => {\n *   let nestedTimeoutInvoked = false;\n *   function funcWithNestedTimeout() {\n *     setTimeout(() => {\n *       nestedTimeoutInvoked = true;\n *     });\n *   };\n *   setTimeout(funcWithNestedTimeout);\n *   tick(0, {processNewMacroTasksSynchronously: false});\n *   expect(nestedTimeoutInvoked).toBe(false);\n * }));\n * ```\n *\n *\n * @publicApi\n */\nfunction tick(millis = 0, tickOptions = {\n    processNewMacroTasksSynchronously: true\n}) {\n    if (fakeAsyncTestModule) {\n        return fakeAsyncTestModule.tick(millis, tickOptions);\n    }\n    throw new Error(fakeAsyncTestModuleNotLoadedErrorMessage);\n}\n/**\n * Simulates the asynchronous passage of time for the timers in the `fakeAsync` zone by\n * draining the macrotask queue until it is empty.\n *\n * @param maxTurns The maximum number of times the scheduler attempts to clear its queue before\n *     throwing an error.\n * @returns The simulated time elapsed, in milliseconds.\n *\n * @publicApi\n */\nfunction flush(maxTurns) {\n    if (fakeAsyncTestModule) {\n        return fakeAsyncTestModule.flush(maxTurns);\n    }\n    throw new Error(fakeAsyncTestModuleNotLoadedErrorMessage);\n}\n/**\n * Discard all remaining periodic tasks.\n *\n * @publicApi\n */\nfunction discardPeriodicTasks() {\n    if (fakeAsyncTestModule) {\n        return fakeAsyncTestModule.discardPeriodicTasks();\n    }\n    throw new Error(fakeAsyncTestModuleNotLoadedErrorMessage);\n}\n/**\n * Flush any pending microtasks.\n *\n * @publicApi\n */\nfunction flushMicrotasks() {\n    if (fakeAsyncTestModule) {\n        return fakeAsyncTestModule.flushMicrotasks();\n    }\n    throw new Error(fakeAsyncTestModuleNotLoadedErrorMessage);\n}\n\n/**\n * @license\n * Copyright Google LLC All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.io/license\n */\n/**\n * Used to resolve resource URLs on `@Component` when used with JIT compilation.\n *\n * Example:\n * ```\n * @Component({\n *   selector: 'my-comp',\n *   templateUrl: 'my-comp.html', // This requires asynchronous resolution\n * })\n * class MyComponent{\n * }\n *\n * // Calling `renderComponent` will fail because `renderComponent` is a synchronous process\n * // and `MyComponent`'s `@Component.templateUrl` needs to be resolved asynchronously.\n *\n * // Calling `resolveComponentResources()` will resolve `@Component.templateUrl` into\n * // `@Component.template`, which allows `renderComponent` to proceed in a synchronous manner.\n *\n * // Use browser's `fetch()` function as the default resource resolution strategy.\n * resolveComponentResources(fetch).then(() => {\n *   // After resolution all URLs have been converted into `template` strings.\n *   renderComponent(MyComponent);\n * });\n *\n * ```\n *\n * NOTE: In AOT the resolution happens during compilation, and so there should be no need\n * to call this method outside JIT mode.\n *\n * @param resourceResolver a function which is responsible for returning a `Promise` to the\n * contents of the resolved URL. Browser's `fetch()` method is a good default implementation.\n */\nfunction resolveComponentResources(resourceResolver) {\n    // Store all promises which are fetching the resources.\n    const componentResolved = [];\n    // Cache so that we don't fetch the same resource more than once.\n    const urlMap = new Map();\n    function cachedResourceResolve(url) {\n        let promise = urlMap.get(url);\n        if (!promise) {\n            const resp = resourceResolver(url);\n            urlMap.set(url, promise = resp.then(unwrapResponse));\n        }\n        return promise;\n    }\n    componentResourceResolutionQueue.forEach((component, type) => {\n        const promises = [];\n        if (component.templateUrl) {\n            promises.push(cachedResourceResolve(component.templateUrl).then((template) => {\n                component.template = template;\n            }));\n        }\n        const styleUrls = component.styleUrls;\n        const styles = component.styles || (component.styles = []);\n        const styleOffset = component.styles.length;\n        styleUrls && styleUrls.forEach((styleUrl, index) => {\n            styles.push(''); // pre-allocate array.\n            promises.push(cachedResourceResolve(styleUrl).then((style) => {\n                styles[styleOffset + index] = style;\n                styleUrls.splice(styleUrls.indexOf(styleUrl), 1);\n                if (styleUrls.length == 0) {\n                    component.styleUrls = undefined;\n                }\n            }));\n        });\n        const fullyResolved = Promise.all(promises).then(() => componentDefResolved(type));\n        componentResolved.push(fullyResolved);\n    });\n    clearResolutionOfComponentResourcesQueue();\n    return Promise.all(componentResolved).then(() => undefined);\n}\nlet componentResourceResolutionQueue = new Map();\n// Track when existing ɵcmp for a Type is waiting on resources.\nconst componentDefPendingResolution = new Set();\nfunction maybeQueueResolutionOfComponentResources(type, metadata) {\n    if (componentNeedsResolution(metadata)) {\n        componentResourceResolutionQueue.set(type, metadata);\n        componentDefPendingResolution.add(type);\n    }\n}\nfunction isComponentDefPendingResolution(type) {\n    return componentDefPendingResolution.has(type);\n}\nfunction componentNeedsResolution(component) {\n    return !!((component.templateUrl && !component.hasOwnProperty('template')) ||\n        component.styleUrls && component.styleUrls.length);\n}\nfunction clearResolutionOfComponentResourcesQueue() {\n    const old = componentResourceResolutionQueue;\n    componentResourceResolutionQueue = new Map();\n    return old;\n}\nfunction restoreComponentResolutionQueue(queue) {\n    componentDefPendingResolution.clear();\n    queue.forEach((_, type) => componentDefPendingResolution.add(type));\n    componentResourceResolutionQueue = queue;\n}\nfunction isComponentResourceResolutionQueueEmpty() {\n    return componentResourceResolutionQueue.size === 0;\n}\nfunction unwrapResponse(response) {\n    return typeof response == 'string' ? response : response.text();\n}\nfunction componentDefResolved(type) {\n    componentDefPendingResolution.delete(type);\n}\n\n/**\n * @license\n * Copyright Google LLC All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.io/license\n */\nlet _nextReferenceId = 0;\nclass MetadataOverrider {\n    constructor() {\n        this._references = new Map();\n    }\n    /**\n     * Creates a new instance for the given metadata class\n     * based on an old instance and overrides.\n     */\n    overrideMetadata(metadataClass, oldMetadata, override) {\n        const props = {};\n        if (oldMetadata) {\n            _valueProps(oldMetadata).forEach((prop) => props[prop] = oldMetadata[prop]);\n        }\n        if (override.set) {\n            if (override.remove || override.add) {\n                throw new Error(`Cannot set and add/remove ${ɵstringify(metadataClass)} at the same time!`);\n            }\n            setMetadata(props, override.set);\n        }\n        if (override.remove) {\n            removeMetadata(props, override.remove, this._references);\n        }\n        if (override.add) {\n            addMetadata(props, override.add);\n        }\n        return new metadataClass(props);\n    }\n}\nfunction removeMetadata(metadata, remove, references) {\n    const removeObjects = new Set();\n    for (const prop in remove) {\n        const removeValue = remove[prop];\n        if (Array.isArray(removeValue)) {\n            removeValue.forEach((value) => {\n                removeObjects.add(_propHashKey(prop, value, references));\n            });\n        }\n        else {\n            removeObjects.add(_propHashKey(prop, removeValue, references));\n        }\n    }\n    for (const prop in metadata) {\n        const propValue = metadata[prop];\n        if (Array.isArray(propValue)) {\n            metadata[prop] = propValue.filter((value) => !removeObjects.has(_propHashKey(prop, value, references)));\n        }\n        else {\n            if (removeObjects.has(_propHashKey(prop, propValue, references))) {\n                metadata[prop] = undefined;\n            }\n        }\n    }\n}\nfunction addMetadata(metadata, add) {\n    for (const prop in add) {\n        const addValue = add[prop];\n        const propValue = metadata[prop];\n        if (propValue != null && Array.isArray(propValue)) {\n            metadata[prop] = propValue.concat(addValue);\n        }\n        else {\n            metadata[prop] = addValue;\n        }\n    }\n}\nfunction setMetadata(metadata, set) {\n    for (const prop in set) {\n        metadata[prop] = set[prop];\n    }\n}\nfunction _propHashKey(propName, propValue, references) {\n    const replacer = (key, value) => {\n        if (typeof value === 'function') {\n            value = _serializeReference(value, references);\n        }\n        return value;\n    };\n    return `${propName}:${JSON.stringify(propValue, replacer)}`;\n}\nfunction _serializeReference(ref, references) {\n    let id = references.get(ref);\n    if (!id) {\n        id = `${ɵstringify(ref)}${_nextReferenceId++}`;\n        references.set(ref, id);\n    }\n    return id;\n}\nfunction _valueProps(obj) {\n    const props = [];\n    // regular public props\n    Object.keys(obj).forEach((prop) => {\n        if (!prop.startsWith('_')) {\n            props.push(prop);\n        }\n    });\n    // getters\n    let proto = obj;\n    while (proto = Object.getPrototypeOf(proto)) {\n        Object.keys(proto).forEach((protoProp) => {\n            const desc = Object.getOwnPropertyDescriptor(proto, protoProp);\n            if (!protoProp.startsWith('_') && desc && 'get' in desc) {\n                props.push(protoProp);\n            }\n        });\n    }\n    return props;\n}\n\n/**\n * @license\n * Copyright Google LLC All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.io/license\n */\nconst reflection = new ɵReflectionCapabilities();\n/**\n * Allows to override ivy metadata for tests (via the `TestBed`).\n */\nclass OverrideResolver {\n    constructor() {\n        this.overrides = new Map();\n        this.resolved = new Map();\n    }\n    addOverride(type, override) {\n        const overrides = this.overrides.get(type) || [];\n        overrides.push(override);\n        this.overrides.set(type, overrides);\n        this.resolved.delete(type);\n    }\n    setOverrides(overrides) {\n        this.overrides.clear();\n        overrides.forEach(([type, override]) => {\n            this.addOverride(type, override);\n        });\n    }\n    getAnnotation(type) {\n        const annotations = reflection.annotations(type);\n        // Try to find the nearest known Type annotation and make sure that this annotation is an\n        // instance of the type we are looking for, so we can use it for resolution. Note: there might\n        // be multiple known annotations found due to the fact that Components can extend Directives (so\n        // both Directive and Component annotations would be present), so we always check if the known\n        // annotation has the right type.\n        for (let i = annotations.length - 1; i >= 0; i--) {\n            const annotation = annotations[i];\n            const isKnownType = annotation instanceof Directive || annotation instanceof Component ||\n                annotation instanceof Pipe || annotation instanceof NgModule;\n            if (isKnownType) {\n                return annotation instanceof this.type ? annotation : null;\n            }\n        }\n        return null;\n    }\n    resolve(type) {\n        let resolved = this.resolved.get(type) || null;\n        if (!resolved) {\n            resolved = this.getAnnotation(type);\n            if (resolved) {\n                const overrides = this.overrides.get(type);\n                if (overrides) {\n                    const overrider = new MetadataOverrider();\n                    overrides.forEach(override => {\n                        resolved = overrider.overrideMetadata(this.type, resolved, override);\n                    });\n                }\n            }\n            this.resolved.set(type, resolved);\n        }\n        return resolved;\n    }\n}\nclass DirectiveResolver extends OverrideResolver {\n    get type() {\n        return Directive;\n    }\n}\nclass ComponentResolver extends OverrideResolver {\n    get type() {\n        return Component;\n    }\n}\nclass PipeResolver extends OverrideResolver {\n    get type() {\n        return Pipe;\n    }\n}\nclass NgModuleResolver extends OverrideResolver {\n    get type() {\n        return NgModule;\n    }\n}\n\n/**\n * @license\n * Copyright Google LLC All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.io/license\n */\nvar TestingModuleOverride;\n(function (TestingModuleOverride) {\n    TestingModuleOverride[TestingModuleOverride[\"DECLARATION\"] = 0] = \"DECLARATION\";\n    TestingModuleOverride[TestingModuleOverride[\"OVERRIDE_TEMPLATE\"] = 1] = \"OVERRIDE_TEMPLATE\";\n})(TestingModuleOverride || (TestingModuleOverride = {}));\nfunction isTestingModuleOverride(value) {\n    return value === TestingModuleOverride.DECLARATION ||\n        value === TestingModuleOverride.OVERRIDE_TEMPLATE;\n}\nclass R3TestBedCompiler {\n    constructor(platform, additionalModuleTypes) {\n        this.platform = platform;\n        this.additionalModuleTypes = additionalModuleTypes;\n        this.originalComponentResolutionQueue = null;\n        // Testing module configuration\n        this.declarations = [];\n        this.imports = [];\n        this.providers = [];\n        this.schemas = [];\n        // Queues of components/directives/pipes that should be recompiled.\n        this.pendingComponents = new Set();\n        this.pendingDirectives = new Set();\n        this.pendingPipes = new Set();\n        // Keep track of all components and directives, so we can patch Providers onto defs later.\n        this.seenComponents = new Set();\n        this.seenDirectives = new Set();\n        // Keep track of overridden modules, so that we can collect all affected ones in the module tree.\n        this.overriddenModules = new Set();\n        // Store resolved styles for Components that have template overrides present and `styleUrls`\n        // defined at the same time.\n        this.existingComponentStyles = new Map();\n        this.resolvers = initResolvers();\n        this.componentToModuleScope = new Map();\n        // Map that keeps initial version of component/directive/pipe defs in case\n        // we compile a Type again, thus overriding respective static fields. This is\n        // required to make sure we restore defs to their initial states between test runs\n        // TODO: we should support the case with multiple defs on a type\n        this.initialNgDefs = new Map();\n        // Array that keeps cleanup operations for initial versions of component/directive/pipe/module\n        // defs in case TestBed makes changes to the originals.\n        this.defCleanupOps = [];\n        this._injector = null;\n        this.compilerProviders = null;\n        this.providerOverrides = [];\n        this.rootProviderOverrides = [];\n        // Overrides for injectables with `{providedIn: SomeModule}` need to be tracked and added to that\n        // module's provider list.\n        this.providerOverridesByModule = new Map();\n        this.providerOverridesByToken = new Map();\n        this.moduleProvidersOverridden = new Set();\n        this.testModuleRef = null;\n        class DynamicTestModule {\n        }\n        this.testModuleType = DynamicTestModule;\n    }\n    setCompilerProviders(providers) {\n        this.compilerProviders = providers;\n        this._injector = null;\n    }\n    configureTestingModule(moduleDef) {\n        // Enqueue any compilation tasks for the directly declared component.\n        if (moduleDef.declarations !== undefined) {\n            this.queueTypeArray(moduleDef.declarations, TestingModuleOverride.DECLARATION);\n            this.declarations.push(...moduleDef.declarations);\n        }\n        // Enqueue any compilation tasks for imported modules.\n        if (moduleDef.imports !== undefined) {\n            this.queueTypesFromModulesArray(moduleDef.imports);\n            this.imports.push(...moduleDef.imports);\n        }\n        if (moduleDef.providers !== undefined) {\n            this.providers.push(...moduleDef.providers);\n        }\n        if (moduleDef.schemas !== undefined) {\n            this.schemas.push(...moduleDef.schemas);\n        }\n    }\n    overrideModule(ngModule, override) {\n        this.overriddenModules.add(ngModule);\n        // Compile the module right away.\n        this.resolvers.module.addOverride(ngModule, override);\n        const metadata = this.resolvers.module.resolve(ngModule);\n        if (metadata === null) {\n            throw invalidTypeError(ngModule.name, 'NgModule');\n        }\n        this.recompileNgModule(ngModule, metadata);\n        // At this point, the module has a valid module def (ɵmod), but the override may have introduced\n        // new declarations or imported modules. Ingest any possible new types and add them to the\n        // current queue.\n        this.queueTypesFromModulesArray([ngModule]);\n    }\n    overrideComponent(component, override) {\n        this.resolvers.component.addOverride(component, override);\n        this.pendingComponents.add(component);\n    }\n    overrideDirective(directive, override) {\n        this.resolvers.directive.addOverride(directive, override);\n        this.pendingDirectives.add(directive);\n    }\n    overridePipe(pipe, override) {\n        this.resolvers.pipe.addOverride(pipe, override);\n        this.pendingPipes.add(pipe);\n    }\n    overrideProvider(token, provider) {\n        let providerDef;\n        if (provider.useFactory !== undefined) {\n            providerDef = {\n                provide: token,\n                useFactory: provider.useFactory,\n                deps: provider.deps || [],\n                multi: provider.multi\n            };\n        }\n        else if (provider.useValue !== undefined) {\n            providerDef = { provide: token, useValue: provider.useValue, multi: provider.multi };\n        }\n        else {\n            providerDef = { provide: token };\n        }\n        const injectableDef = typeof token !== 'string' ? ɵgetInjectableDef(token) : null;\n        const providedIn = injectableDef === null ? null : resolveForwardRef(injectableDef.providedIn);\n        const overridesBucket = providedIn === 'root' ? this.rootProviderOverrides : this.providerOverrides;\n        overridesBucket.push(providerDef);\n        // Keep overrides grouped by token as well for fast lookups using token\n        this.providerOverridesByToken.set(token, providerDef);\n        if (injectableDef !== null && providedIn !== null && typeof providedIn !== 'string') {\n            const existingOverrides = this.providerOverridesByModule.get(providedIn);\n            if (existingOverrides !== undefined) {\n                existingOverrides.push(providerDef);\n            }\n            else {\n                this.providerOverridesByModule.set(providedIn, [providerDef]);\n            }\n        }\n    }\n    overrideTemplateUsingTestingModule(type, template) {\n        const def = type[ɵNG_COMP_DEF];\n        const hasStyleUrls = () => {\n            const metadata = this.resolvers.component.resolve(type);\n            return !!metadata.styleUrls && metadata.styleUrls.length > 0;\n        };\n        const overrideStyleUrls = !!def && !isComponentDefPendingResolution(type) && hasStyleUrls();\n        // In Ivy, compiling a component does not require knowing the module providing the\n        // component's scope, so overrideTemplateUsingTestingModule can be implemented purely via\n        // overrideComponent. Important: overriding template requires full Component re-compilation,\n        // which may fail in case styleUrls are also present (thus Component is considered as required\n        // resolution). In order to avoid this, we preemptively set styleUrls to an empty array,\n        // preserve current styles available on Component def and restore styles back once compilation\n        // is complete.\n        const override = overrideStyleUrls ? { template, styles: [], styleUrls: [] } : { template };\n        this.overrideComponent(type, { set: override });\n        if (overrideStyleUrls && def.styles && def.styles.length > 0) {\n            this.existingComponentStyles.set(type, def.styles);\n        }\n        // Set the component's scope to be the testing module.\n        this.componentToModuleScope.set(type, TestingModuleOverride.OVERRIDE_TEMPLATE);\n    }\n    compileComponents() {\n        return __awaiter(this, void 0, void 0, function* () {\n            this.clearComponentResolutionQueue();\n            // Run compilers for all queued types.\n            let needsAsyncResources = this.compileTypesSync();\n            // compileComponents() should not be async unless it needs to be.\n            if (needsAsyncResources) {\n                let resourceLoader;\n                let resolver = (url) => {\n                    if (!resourceLoader) {\n                        resourceLoader = this.injector.get(ResourceLoader);\n                    }\n                    return Promise.resolve(resourceLoader.get(url));\n                };\n                yield resolveComponentResources(resolver);\n            }\n        });\n    }\n    finalize() {\n        // One last compile\n        this.compileTypesSync();\n        // Create the testing module itself.\n        this.compileTestModule();\n        this.applyTransitiveScopes();\n        this.applyProviderOverrides();\n        // Patch previously stored `styles` Component values (taken from ɵcmp), in case these\n        // Components have `styleUrls` fields defined and template override was requested.\n        this.patchComponentsWithExistingStyles();\n        // Clear the componentToModuleScope map, so that future compilations don't reset the scope of\n        // every component.\n        this.componentToModuleScope.clear();\n        const parentInjector = this.platform.injector;\n        this.testModuleRef = new ɵRender3NgModuleRef(this.testModuleType, parentInjector);\n        // ApplicationInitStatus.runInitializers() is marked @internal to core.\n        // Cast it to any before accessing it.\n        this.testModuleRef.injector.get(ApplicationInitStatus).runInitializers();\n        // Set locale ID after running app initializers, since locale information might be updated while\n        // running initializers. This is also consistent with the execution order while bootstrapping an\n        // app (see `packages/core/src/application_ref.ts` file).\n        const localeId = this.testModuleRef.injector.get(LOCALE_ID, ɵDEFAULT_LOCALE_ID);\n        ɵsetLocaleId(localeId);\n        return this.testModuleRef;\n    }\n    /**\n     * @internal\n     */\n    _compileNgModuleSync(moduleType) {\n        this.queueTypesFromModulesArray([moduleType]);\n        this.compileTypesSync();\n        this.applyProviderOverrides();\n        this.applyProviderOverridesToModule(moduleType);\n        this.applyTransitiveScopes();\n    }\n    /**\n     * @internal\n     */\n    _compileNgModuleAsync(moduleType) {\n        return __awaiter(this, void 0, void 0, function* () {\n            this.queueTypesFromModulesArray([moduleType]);\n            yield this.compileComponents();\n            this.applyProviderOverrides();\n            this.applyProviderOverridesToModule(moduleType);\n            this.applyTransitiveScopes();\n        });\n    }\n    /**\n     * @internal\n     */\n    _getModuleResolver() {\n        return this.resolvers.module;\n    }\n    /**\n     * @internal\n     */\n    _getComponentFactories(moduleType) {\n        return maybeUnwrapFn(moduleType.ɵmod.declarations).reduce((factories, declaration) => {\n            const componentDef = declaration.ɵcmp;\n            componentDef && factories.push(new ɵRender3ComponentFactory(componentDef, this.testModuleRef));\n            return factories;\n        }, []);\n    }\n    compileTypesSync() {\n        // Compile all queued components, directives, pipes.\n        let needsAsyncResources = false;\n        this.pendingComponents.forEach(declaration => {\n            needsAsyncResources = needsAsyncResources || isComponentDefPendingResolution(declaration);\n            const metadata = this.resolvers.component.resolve(declaration);\n            if (metadata === null) {\n                throw invalidTypeError(declaration.name, 'Component');\n            }\n            this.maybeStoreNgDef(ɵNG_COMP_DEF, declaration);\n            ɵcompileComponent(declaration, metadata);\n        });\n        this.pendingComponents.clear();\n        this.pendingDirectives.forEach(declaration => {\n            const metadata = this.resolvers.directive.resolve(declaration);\n            if (metadata === null) {\n                throw invalidTypeError(declaration.name, 'Directive');\n            }\n            this.maybeStoreNgDef(ɵNG_DIR_DEF, declaration);\n            ɵcompileDirective(declaration, metadata);\n        });\n        this.pendingDirectives.clear();\n        this.pendingPipes.forEach(declaration => {\n            const metadata = this.resolvers.pipe.resolve(declaration);\n            if (metadata === null) {\n                throw invalidTypeError(declaration.name, 'Pipe');\n            }\n            this.maybeStoreNgDef(ɵNG_PIPE_DEF, declaration);\n            ɵcompilePipe(declaration, metadata);\n        });\n        this.pendingPipes.clear();\n        return needsAsyncResources;\n    }\n    applyTransitiveScopes() {\n        if (this.overriddenModules.size > 0) {\n            // Module overrides (via `TestBed.overrideModule`) might affect scopes that were previously\n            // calculated and stored in `transitiveCompileScopes`. If module overrides are present,\n            // collect all affected modules and reset scopes to force their re-calculation.\n            const testingModuleDef = this.testModuleType[ɵNG_MOD_DEF];\n            const affectedModules = this.collectModulesAffectedByOverrides(testingModuleDef.imports);\n            if (affectedModules.size > 0) {\n                affectedModules.forEach(moduleType => {\n                    this.storeFieldOfDefOnType(moduleType, ɵNG_MOD_DEF, 'transitiveCompileScopes');\n                    moduleType[ɵNG_MOD_DEF].transitiveCompileScopes = null;\n                });\n            }\n        }\n        const moduleToScope = new Map();\n        const getScopeOfModule = (moduleType) => {\n            if (!moduleToScope.has(moduleType)) {\n                const isTestingModule = isTestingModuleOverride(moduleType);\n                const realType = isTestingModule ? this.testModuleType : moduleType;\n                moduleToScope.set(moduleType, ɵtransitiveScopesFor(realType));\n            }\n            return moduleToScope.get(moduleType);\n        };\n        this.componentToModuleScope.forEach((moduleType, componentType) => {\n            const moduleScope = getScopeOfModule(moduleType);\n            this.storeFieldOfDefOnType(componentType, ɵNG_COMP_DEF, 'directiveDefs');\n            this.storeFieldOfDefOnType(componentType, ɵNG_COMP_DEF, 'pipeDefs');\n            // `tView` that is stored on component def contains information about directives and pipes\n            // that are in the scope of this component. Patching component scope will cause `tView` to be\n            // changed. Store original `tView` before patching scope, so the `tView` (including scope\n            // information) is restored back to its previous/original state before running next test.\n            this.storeFieldOfDefOnType(componentType, ɵNG_COMP_DEF, 'tView');\n            ɵpatchComponentDefWithScope(componentType.ɵcmp, moduleScope);\n        });\n        this.componentToModuleScope.clear();\n    }\n    applyProviderOverrides() {\n        const maybeApplyOverrides = (field) => (type) => {\n            const resolver = field === ɵNG_COMP_DEF ? this.resolvers.component : this.resolvers.directive;\n            const metadata = resolver.resolve(type);\n            if (this.hasProviderOverrides(metadata.providers)) {\n                this.patchDefWithProviderOverrides(type, field);\n            }\n        };\n        this.seenComponents.forEach(maybeApplyOverrides(ɵNG_COMP_DEF));\n        this.seenDirectives.forEach(maybeApplyOverrides(ɵNG_DIR_DEF));\n        this.seenComponents.clear();\n        this.seenDirectives.clear();\n    }\n    applyProviderOverridesToModule(moduleType) {\n        if (this.moduleProvidersOverridden.has(moduleType)) {\n            return;\n        }\n        this.moduleProvidersOverridden.add(moduleType);\n        const injectorDef = moduleType[ɵNG_INJ_DEF];\n        if (this.providerOverridesByToken.size > 0) {\n            const providers = [\n                ...injectorDef.providers,\n                ...(this.providerOverridesByModule.get(moduleType) || [])\n            ];\n            if (this.hasProviderOverrides(providers)) {\n                this.maybeStoreNgDef(ɵNG_INJ_DEF, moduleType);\n                this.storeFieldOfDefOnType(moduleType, ɵNG_INJ_DEF, 'providers');\n                injectorDef.providers = this.getOverriddenProviders(providers);\n            }\n            // Apply provider overrides to imported modules recursively\n            const moduleDef = moduleType[ɵNG_MOD_DEF];\n            const imports = maybeUnwrapFn(moduleDef.imports);\n            for (const importedModule of imports) {\n                this.applyProviderOverridesToModule(importedModule);\n            }\n            // Also override the providers on any ModuleWithProviders imports since those don't appear in\n            // the moduleDef.\n            for (const importedModule of flatten(injectorDef.imports)) {\n                if (isModuleWithProviders(importedModule)) {\n                    this.defCleanupOps.push({\n                        object: importedModule,\n                        fieldName: 'providers',\n                        originalValue: importedModule.providers\n                    });\n                    importedModule.providers = this.getOverriddenProviders(importedModule.providers);\n                }\n            }\n        }\n    }\n    patchComponentsWithExistingStyles() {\n        this.existingComponentStyles.forEach((styles, type) => type[ɵNG_COMP_DEF].styles = styles);\n        this.existingComponentStyles.clear();\n    }\n    queueTypeArray(arr, moduleType) {\n        for (const value of arr) {\n            if (Array.isArray(value)) {\n                this.queueTypeArray(value, moduleType);\n            }\n            else {\n                this.queueType(value, moduleType);\n            }\n        }\n    }\n    recompileNgModule(ngModule, metadata) {\n        // Cache the initial ngModuleDef as it will be overwritten.\n        this.maybeStoreNgDef(ɵNG_MOD_DEF, ngModule);\n        this.maybeStoreNgDef(ɵNG_INJ_DEF, ngModule);\n        ɵcompileNgModuleDefs(ngModule, metadata);\n    }\n    queueType(type, moduleType) {\n        const component = this.resolvers.component.resolve(type);\n        if (component) {\n            // Check whether a give Type has respective NG def (ɵcmp) and compile if def is\n            // missing. That might happen in case a class without any Angular decorators extends another\n            // class where Component/Directive/Pipe decorator is defined.\n            if (isComponentDefPendingResolution(type) || !type.hasOwnProperty(ɵNG_COMP_DEF)) {\n                this.pendingComponents.add(type);\n            }\n            this.seenComponents.add(type);\n            // Keep track of the module which declares this component, so later the component's scope\n            // can be set correctly. If the component has already been recorded here, then one of several\n            // cases is true:\n            // * the module containing the component was imported multiple times (common).\n            // * the component is declared in multiple modules (which is an error).\n            // * the component was in 'declarations' of the testing module, and also in an imported module\n            //   in which case the module scope will be TestingModuleOverride.DECLARATION.\n            // * overrideTemplateUsingTestingModule was called for the component in which case the module\n            //   scope will be TestingModuleOverride.OVERRIDE_TEMPLATE.\n            //\n            // If the component was previously in the testing module's 'declarations' (meaning the\n            // current value is TestingModuleOverride.DECLARATION), then `moduleType` is the component's\n            // real module, which was imported. This pattern is understood to mean that the component\n            // should use its original scope, but that the testing module should also contain the\n            // component in its scope.\n            if (!this.componentToModuleScope.has(type) ||\n                this.componentToModuleScope.get(type) === TestingModuleOverride.DECLARATION) {\n                this.componentToModuleScope.set(type, moduleType);\n            }\n            return;\n        }\n        const directive = this.resolvers.directive.resolve(type);\n        if (directive) {\n            if (!type.hasOwnProperty(ɵNG_DIR_DEF)) {\n                this.pendingDirectives.add(type);\n            }\n            this.seenDirectives.add(type);\n            return;\n        }\n        const pipe = this.resolvers.pipe.resolve(type);\n        if (pipe && !type.hasOwnProperty(ɵNG_PIPE_DEF)) {\n            this.pendingPipes.add(type);\n            return;\n        }\n    }\n    queueTypesFromModulesArray(arr) {\n        // Because we may encounter the same NgModule while processing the imports and exports of an\n        // NgModule tree, we cache them in this set so we can skip ones that have already been seen\n        // encountered. In some test setups, this caching resulted in 10X runtime improvement.\n        const processedNgModuleDefs = new Set();\n        const queueTypesFromModulesArrayRecur = (arr) => {\n            for (const value of arr) {\n                if (Array.isArray(value)) {\n                    queueTypesFromModulesArrayRecur(value);\n                }\n                else if (hasNgModuleDef(value)) {\n                    const def = value.ɵmod;\n                    if (processedNgModuleDefs.has(def)) {\n                        continue;\n                    }\n                    processedNgModuleDefs.add(def);\n                    // Look through declarations, imports, and exports, and queue\n                    // everything found there.\n                    this.queueTypeArray(maybeUnwrapFn(def.declarations), value);\n                    queueTypesFromModulesArrayRecur(maybeUnwrapFn(def.imports));\n                    queueTypesFromModulesArrayRecur(maybeUnwrapFn(def.exports));\n                }\n                else if (isModuleWithProviders(value)) {\n                    queueTypesFromModulesArrayRecur([value.ngModule]);\n                }\n            }\n        };\n        queueTypesFromModulesArrayRecur(arr);\n    }\n    // When module overrides (via `TestBed.overrideModule`) are present, it might affect all modules\n    // that import (even transitively) an overridden one. For all affected modules we need to\n    // recalculate their scopes for a given test run and restore original scopes at the end. The goal\n    // of this function is to collect all affected modules in a set for further processing. Example:\n    // if we have the following module hierarchy: A -> B -> C (where `->` means `imports`) and module\n    // `C` is overridden, we consider `A` and `B` as affected, since their scopes might become\n    // invalidated with the override.\n    collectModulesAffectedByOverrides(arr) {\n        const seenModules = new Set();\n        const affectedModules = new Set();\n        const calcAffectedModulesRecur = (arr, path) => {\n            for (const value of arr) {\n                if (Array.isArray(value)) {\n                    // If the value is an array, just flatten it (by invoking this function recursively),\n                    // keeping \"path\" the same.\n                    calcAffectedModulesRecur(value, path);\n                }\n                else if (hasNgModuleDef(value)) {\n                    if (seenModules.has(value)) {\n                        // If we've seen this module before and it's included into \"affected modules\" list, mark\n                        // the whole path that leads to that module as affected, but do not descend into its\n                        // imports, since we already examined them before.\n                        if (affectedModules.has(value)) {\n                            path.forEach(item => affectedModules.add(item));\n                        }\n                        continue;\n                    }\n                    seenModules.add(value);\n                    if (this.overriddenModules.has(value)) {\n                        path.forEach(item => affectedModules.add(item));\n                    }\n                    // Examine module imports recursively to look for overridden modules.\n                    const moduleDef = value[ɵNG_MOD_DEF];\n                    calcAffectedModulesRecur(maybeUnwrapFn(moduleDef.imports), path.concat(value));\n                }\n            }\n        };\n        calcAffectedModulesRecur(arr, []);\n        return affectedModules;\n    }\n    maybeStoreNgDef(prop, type) {\n        if (!this.initialNgDefs.has(type)) {\n            const currentDef = Object.getOwnPropertyDescriptor(type, prop);\n            this.initialNgDefs.set(type, [prop, currentDef]);\n        }\n    }\n    storeFieldOfDefOnType(type, defField, fieldName) {\n        const def = type[defField];\n        const originalValue = def[fieldName];\n        this.defCleanupOps.push({ object: def, fieldName, originalValue });\n    }\n    /**\n     * Clears current components resolution queue, but stores the state of the queue, so we can\n     * restore it later. Clearing the queue is required before we try to compile components (via\n     * `TestBed.compileComponents`), so that component defs are in sync with the resolution queue.\n     */\n    clearComponentResolutionQueue() {\n        if (this.originalComponentResolutionQueue === null) {\n            this.originalComponentResolutionQueue = new Map();\n        }\n        clearResolutionOfComponentResourcesQueue().forEach((value, key) => this.originalComponentResolutionQueue.set(key, value));\n    }\n    /*\n     * Restores component resolution queue to the previously saved state. This operation is performed\n     * as a part of restoring the state after completion of the current set of tests (that might\n     * potentially mutate the state).\n     */\n    restoreComponentResolutionQueue() {\n        if (this.originalComponentResolutionQueue !== null) {\n            restoreComponentResolutionQueue(this.originalComponentResolutionQueue);\n            this.originalComponentResolutionQueue = null;\n        }\n    }\n    restoreOriginalState() {\n        // Process cleanup ops in reverse order so the field's original value is restored correctly (in\n        // case there were multiple overrides for the same field).\n        forEachRight(this.defCleanupOps, (op) => {\n            op.object[op.fieldName] = op.originalValue;\n        });\n        // Restore initial component/directive/pipe defs\n        this.initialNgDefs.forEach((value, type) => {\n            const [prop, descriptor] = value;\n            if (!descriptor) {\n                // Delete operations are generally undesirable since they have performance implications\n                // on objects they were applied to. In this particular case, situations where this code\n                // is invoked should be quite rare to cause any noticeable impact, since it's applied\n                // only to some test cases (for example when class with no annotations extends some\n                // @Component) when we need to clear 'ɵcmp' field on a given class to restore\n                // its original state (before applying overrides and running tests).\n                delete type[prop];\n            }\n            else {\n                Object.defineProperty(type, prop, descriptor);\n            }\n        });\n        this.initialNgDefs.clear();\n        this.moduleProvidersOverridden.clear();\n        this.restoreComponentResolutionQueue();\n        // Restore the locale ID to the default value, this shouldn't be necessary but we never know\n        ɵsetLocaleId(ɵDEFAULT_LOCALE_ID);\n    }\n    compileTestModule() {\n        class RootScopeModule {\n        }\n        ɵcompileNgModuleDefs(RootScopeModule, {\n            providers: [...this.rootProviderOverrides],\n        });\n        const ngZone = new NgZone({ enableLongStackTrace: true });\n        const providers = [\n            { provide: NgZone, useValue: ngZone },\n            { provide: Compiler, useFactory: () => new R3TestCompiler(this) },\n            ...this.providers,\n            ...this.providerOverrides,\n        ];\n        const imports = [RootScopeModule, this.additionalModuleTypes, this.imports || []];\n        // clang-format off\n        ɵcompileNgModuleDefs(this.testModuleType, {\n            declarations: this.declarations,\n            imports,\n            schemas: this.schemas,\n            providers,\n        }, /* allowDuplicateDeclarationsInRoot */ true);\n        // clang-format on\n        this.applyProviderOverridesToModule(this.testModuleType);\n    }\n    get injector() {\n        if (this._injector !== null) {\n            return this._injector;\n        }\n        const providers = [];\n        const compilerOptions = this.platform.injector.get(COMPILER_OPTIONS);\n        compilerOptions.forEach(opts => {\n            if (opts.providers) {\n                providers.push(opts.providers);\n            }\n        });\n        if (this.compilerProviders !== null) {\n            providers.push(...this.compilerProviders);\n        }\n        // TODO(ocombe): make this work with an Injector directly instead of creating a module for it\n        class CompilerModule {\n        }\n        ɵcompileNgModuleDefs(CompilerModule, { providers });\n        const CompilerModuleFactory = new ɵNgModuleFactory(CompilerModule);\n        this._injector = CompilerModuleFactory.create(this.platform.injector).injector;\n        return this._injector;\n    }\n    // get overrides for a specific provider (if any)\n    getSingleProviderOverrides(provider) {\n        const token = getProviderToken(provider);\n        return this.providerOverridesByToken.get(token) || null;\n    }\n    getProviderOverrides(providers) {\n        if (!providers || !providers.length || this.providerOverridesByToken.size === 0)\n            return [];\n        // There are two flattening operations here. The inner flatten() operates on the metadata's\n        // providers and applies a mapping function which retrieves overrides for each incoming\n        // provider. The outer flatten() then flattens the produced overrides array. If this is not\n        // done, the array can contain other empty arrays (e.g. `[[], []]`) which leak into the\n        // providers array and contaminate any error messages that might be generated.\n        return flatten(flatten(providers, (provider) => this.getSingleProviderOverrides(provider) || []));\n    }\n    getOverriddenProviders(providers) {\n        if (!providers || !providers.length || this.providerOverridesByToken.size === 0)\n            return [];\n        const flattenedProviders = flatten(providers);\n        const overrides = this.getProviderOverrides(flattenedProviders);\n        const overriddenProviders = [...flattenedProviders, ...overrides];\n        const final = [];\n        const seenOverriddenProviders = new Set();\n        // We iterate through the list of providers in reverse order to make sure provider overrides\n        // take precedence over the values defined in provider list. We also filter out all providers\n        // that have overrides, keeping overridden values only. This is needed, since presence of a\n        // provider with `ngOnDestroy` hook will cause this hook to be registered and invoked later.\n        forEachRight(overriddenProviders, (provider) => {\n            const token = getProviderToken(provider);\n            if (this.providerOverridesByToken.has(token)) {\n                if (!seenOverriddenProviders.has(token)) {\n                    seenOverriddenProviders.add(token);\n                    // Treat all overridden providers as `{multi: false}` (even if it's a multi-provider) to\n                    // make sure that provided override takes highest precedence and is not combined with\n                    // other instances of the same multi provider.\n                    final.unshift(Object.assign(Object.assign({}, provider), { multi: false }));\n                }\n            }\n            else {\n                final.unshift(provider);\n            }\n        });\n        return final;\n    }\n    hasProviderOverrides(providers) {\n        return this.getProviderOverrides(providers).length > 0;\n    }\n    patchDefWithProviderOverrides(declaration, field) {\n        const def = declaration[field];\n        if (def && def.providersResolver) {\n            this.maybeStoreNgDef(field, declaration);\n            const resolver = def.providersResolver;\n            const processProvidersFn = (providers) => this.getOverriddenProviders(providers);\n            this.storeFieldOfDefOnType(declaration, field, 'providersResolver');\n            def.providersResolver = (ngDef) => resolver(ngDef, processProvidersFn);\n        }\n    }\n}\nfunction initResolvers() {\n    return {\n        module: new NgModuleResolver(),\n        component: new ComponentResolver(),\n        directive: new DirectiveResolver(),\n        pipe: new PipeResolver()\n    };\n}\nfunction hasNgModuleDef(value) {\n    return value.hasOwnProperty('ɵmod');\n}\nfunction maybeUnwrapFn(maybeFn) {\n    return maybeFn instanceof Function ? maybeFn() : maybeFn;\n}\nfunction flatten(values, mapFn) {\n    const out = [];\n    values.forEach(value => {\n        if (Array.isArray(value)) {\n            out.push(...flatten(value, mapFn));\n        }\n        else {\n            out.push(mapFn ? mapFn(value) : value);\n        }\n    });\n    return out;\n}\nfunction getProviderField(provider, field) {\n    return provider && typeof provider === 'object' && provider[field];\n}\nfunction getProviderToken(provider) {\n    return getProviderField(provider, 'provide') || provider;\n}\nfunction isModuleWithProviders(value) {\n    return value.hasOwnProperty('ngModule');\n}\nfunction forEachRight(values, fn) {\n    for (let idx = values.length - 1; idx >= 0; idx--) {\n        fn(values[idx], idx);\n    }\n}\nfunction invalidTypeError(name, expectedType) {\n    return new Error(`${name} class doesn't have @${expectedType} decorator or is missing metadata.`);\n}\nclass R3TestCompiler {\n    constructor(testBed) {\n        this.testBed = testBed;\n    }\n    compileModuleSync(moduleType) {\n        this.testBed._compileNgModuleSync(moduleType);\n        return new ɵNgModuleFactory(moduleType);\n    }\n    compileModuleAsync(moduleType) {\n        return __awaiter(this, void 0, void 0, function* () {\n            yield this.testBed._compileNgModuleAsync(moduleType);\n            return new ɵNgModuleFactory(moduleType);\n        });\n    }\n    compileModuleAndAllComponentsSync(moduleType) {\n        const ngModuleFactory = this.compileModuleSync(moduleType);\n        const componentFactories = this.testBed._getComponentFactories(moduleType);\n        return new ModuleWithComponentFactories(ngModuleFactory, componentFactories);\n    }\n    compileModuleAndAllComponentsAsync(moduleType) {\n        return __awaiter(this, void 0, void 0, function* () {\n            const ngModuleFactory = yield this.compileModuleAsync(moduleType);\n            const componentFactories = this.testBed._getComponentFactories(moduleType);\n            return new ModuleWithComponentFactories(ngModuleFactory, componentFactories);\n        });\n    }\n    clearCache() { }\n    clearCacheFor(type) { }\n    getModuleId(moduleType) {\n        const meta = this.testBed._getModuleResolver().resolve(moduleType);\n        return meta && meta.id || undefined;\n    }\n}\n\n/**\n * @license\n * Copyright Google LLC All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.io/license\n */\n/**\n * Whether test modules should be torn down by default.\n * Currently disabled for backwards-compatibility reasons.\n */\nconst TEARDOWN_TESTING_MODULE_ON_DESTROY_DEFAULT = false;\n/**\n * An abstract class for inserting the root test component element in a platform independent way.\n *\n * @publicApi\n */\nclass TestComponentRenderer {\n    insertRootElement(rootElementId) { }\n    removeAllRootElements() { }\n}\n/**\n * @publicApi\n */\nconst ComponentFixtureAutoDetect = new InjectionToken('ComponentFixtureAutoDetect');\n/**\n * @publicApi\n */\nconst ComponentFixtureNoNgZone = new InjectionToken('ComponentFixtureNoNgZone');\n\n/**\n * @license\n * Copyright Google LLC All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.io/license\n */\nlet _nextRootElementId = 0;\n/**\n * @description\n * Configures and initializes environment for unit testing and provides methods for\n * creating components and services in unit tests.\n *\n * TestBed is the primary api for writing unit tests for Angular applications and libraries.\n *\n * Note: Use `TestBed` in tests. It will be set to either `TestBedViewEngine` or `TestBedRender3`\n * according to the compiler used.\n */\nclass TestBedRender3 {\n    constructor() {\n        // Properties\n        this.platform = null;\n        this.ngModule = null;\n        this._compiler = null;\n        this._testModuleRef = null;\n        this._activeFixtures = [];\n        this._globalCompilationChecked = false;\n    }\n    /**\n     * Initialize the environment for testing with a compiler factory, a PlatformRef, and an\n     * angular module. These are common to every test in the suite.\n     *\n     * This may only be called once, to set up the common providers for the current test\n     * suite on the current platform. If you absolutely need to change the providers,\n     * first use `resetTestEnvironment`.\n     *\n     * Test modules and platforms for individual platforms are available from\n     * '@angular/<platform_name>/testing'.\n     *\n     * @publicApi\n     */\n    static initTestEnvironment(ngModule, platform, summariesOrOptions) {\n        const testBed = _getTestBedRender3();\n        testBed.initTestEnvironment(ngModule, platform, summariesOrOptions);\n        return testBed;\n    }\n    /**\n     * Reset the providers for the test injector.\n     *\n     * @publicApi\n     */\n    static resetTestEnvironment() {\n        _getTestBedRender3().resetTestEnvironment();\n    }\n    static configureCompiler(config) {\n        _getTestBedRender3().configureCompiler(config);\n        return TestBedRender3;\n    }\n    /**\n     * Allows overriding default providers, directives, pipes, modules of the test injector,\n     * which are defined in test_injector.js\n     */\n    static configureTestingModule(moduleDef) {\n        _getTestBedRender3().configureTestingModule(moduleDef);\n        return TestBedRender3;\n    }\n    /**\n     * Compile components with a `templateUrl` for the test's NgModule.\n     * It is necessary to call this function\n     * as fetching urls is asynchronous.\n     */\n    static compileComponents() {\n        return _getTestBedRender3().compileComponents();\n    }\n    static overrideModule(ngModule, override) {\n        _getTestBedRender3().overrideModule(ngModule, override);\n        return TestBedRender3;\n    }\n    static overrideComponent(component, override) {\n        _getTestBedRender3().overrideComponent(component, override);\n        return TestBedRender3;\n    }\n    static overrideDirective(directive, override) {\n        _getTestBedRender3().overrideDirective(directive, override);\n        return TestBedRender3;\n    }\n    static overridePipe(pipe, override) {\n        _getTestBedRender3().overridePipe(pipe, override);\n        return TestBedRender3;\n    }\n    static overrideTemplate(component, template) {\n        _getTestBedRender3().overrideComponent(component, { set: { template, templateUrl: null } });\n        return TestBedRender3;\n    }\n    /**\n     * Overrides the template of the given component, compiling the template\n     * in the context of the TestingModule.\n     *\n     * Note: This works for JIT and AOTed components as well.\n     */\n    static overrideTemplateUsingTestingModule(component, template) {\n        _getTestBedRender3().overrideTemplateUsingTestingModule(component, template);\n        return TestBedRender3;\n    }\n    static overrideProvider(token, provider) {\n        _getTestBedRender3().overrideProvider(token, provider);\n        return TestBedRender3;\n    }\n    static inject(token, notFoundValue, flags) {\n        return _getTestBedRender3().inject(token, notFoundValue, flags);\n    }\n    /** @deprecated from v9.0.0 use TestBed.inject */\n    static get(token, notFoundValue = Injector.THROW_IF_NOT_FOUND, flags = InjectFlags.Default) {\n        return _getTestBedRender3().inject(token, notFoundValue, flags);\n    }\n    static createComponent(component) {\n        return _getTestBedRender3().createComponent(component);\n    }\n    static resetTestingModule() {\n        _getTestBedRender3().resetTestingModule();\n        return TestBedRender3;\n    }\n    static shouldTearDownTestingModule() {\n        return _getTestBedRender3().shouldTearDownTestingModule();\n    }\n    static tearDownTestingModule() {\n        _getTestBedRender3().tearDownTestingModule();\n    }\n    /**\n     * Initialize the environment for testing with a compiler factory, a PlatformRef, and an\n     * angular module. These are common to every test in the suite.\n     *\n     * This may only be called once, to set up the common providers for the current test\n     * suite on the current platform. If you absolutely need to change the providers,\n     * first use `resetTestEnvironment`.\n     *\n     * Test modules and platforms for individual platforms are available from\n     * '@angular/<platform_name>/testing'.\n     *\n     * @publicApi\n     */\n    initTestEnvironment(ngModule, platform, summariesOrOptions) {\n        if (this.platform || this.ngModule) {\n            throw new Error('Cannot set base providers because it has already been called');\n        }\n        // If `summariesOrOptions` is a function, it means that it's\n        // an AOT summaries factory which Ivy doesn't support.\n        TestBedRender3._environmentTeardownOptions =\n            typeof summariesOrOptions === 'function' ? undefined : summariesOrOptions === null || summariesOrOptions === void 0 ? void 0 : summariesOrOptions.teardown;\n        this.platform = platform;\n        this.ngModule = ngModule;\n        this._compiler = new R3TestBedCompiler(this.platform, this.ngModule);\n    }\n    /**\n     * Reset the providers for the test injector.\n     *\n     * @publicApi\n     */\n    resetTestEnvironment() {\n        this.resetTestingModule();\n        this._compiler = null;\n        this.platform = null;\n        this.ngModule = null;\n        TestBedRender3._environmentTeardownOptions = undefined;\n    }\n    resetTestingModule() {\n        this.checkGlobalCompilationFinished();\n        ɵresetCompiledComponents();\n        if (this._compiler !== null) {\n            this.compiler.restoreOriginalState();\n        }\n        this._compiler = new R3TestBedCompiler(this.platform, this.ngModule);\n        // We have to chain a couple of try/finally blocks, because each step can\n        // throw errors and we don't want it to interrupt the next step and we also\n        // want an error to be thrown at the end.\n        try {\n            this.destroyActiveFixtures();\n        }\n        finally {\n            try {\n                if (this.shouldTearDownTestingModule()) {\n                    this.tearDownTestingModule();\n                }\n            }\n            finally {\n                this._testModuleRef = null;\n                this._instanceTeardownOptions = undefined;\n            }\n        }\n    }\n    configureCompiler(config) {\n        if (config.useJit != null) {\n            throw new Error('the Render3 compiler JiT mode is not configurable !');\n        }\n        if (config.providers !== undefined) {\n            this.compiler.setCompilerProviders(config.providers);\n        }\n    }\n    configureTestingModule(moduleDef) {\n        this.assertNotInstantiated('R3TestBed.configureTestingModule', 'configure the test module');\n        // Always re-assign the teardown options, even if they're undefined.\n        // This ensures that we don't carry the options between tests.\n        this._instanceTeardownOptions = moduleDef.teardown;\n        this.compiler.configureTestingModule(moduleDef);\n    }\n    compileComponents() {\n        return this.compiler.compileComponents();\n    }\n    inject(token, notFoundValue, flags) {\n        if (token === TestBedRender3) {\n            return this;\n        }\n        const UNDEFINED = {};\n        const result = this.testModuleRef.injector.get(token, UNDEFINED, flags);\n        return result === UNDEFINED ? this.compiler.injector.get(token, notFoundValue, flags) :\n            result;\n    }\n    /** @deprecated from v9.0.0 use TestBed.inject */\n    get(token, notFoundValue = Injector.THROW_IF_NOT_FOUND, flags = InjectFlags.Default) {\n        return this.inject(token, notFoundValue, flags);\n    }\n    execute(tokens, fn, context) {\n        const params = tokens.map(t => this.inject(t));\n        return fn.apply(context, params);\n    }\n    overrideModule(ngModule, override) {\n        this.assertNotInstantiated('overrideModule', 'override module metadata');\n        this.compiler.overrideModule(ngModule, override);\n    }\n    overrideComponent(component, override) {\n        this.assertNotInstantiated('overrideComponent', 'override component metadata');\n        this.compiler.overrideComponent(component, override);\n    }\n    overrideTemplateUsingTestingModule(component, template) {\n        this.assertNotInstantiated('R3TestBed.overrideTemplateUsingTestingModule', 'Cannot override template when the test module has already been instantiated');\n        this.compiler.overrideTemplateUsingTestingModule(component, template);\n    }\n    overrideDirective(directive, override) {\n        this.assertNotInstantiated('overrideDirective', 'override directive metadata');\n        this.compiler.overrideDirective(directive, override);\n    }\n    overridePipe(pipe, override) {\n        this.assertNotInstantiated('overridePipe', 'override pipe metadata');\n        this.compiler.overridePipe(pipe, override);\n    }\n    /**\n     * Overwrites all providers for the given token with the given provider definition.\n     */\n    overrideProvider(token, provider) {\n        this.assertNotInstantiated('overrideProvider', 'override provider');\n        this.compiler.overrideProvider(token, provider);\n    }\n    createComponent(type) {\n        const testComponentRenderer = this.inject(TestComponentRenderer);\n        const rootElId = `root${_nextRootElementId++}`;\n        testComponentRenderer.insertRootElement(rootElId);\n        const componentDef = type.ɵcmp;\n        if (!componentDef) {\n            throw new Error(`It looks like '${ɵstringify(type)}' has not been IVY compiled - it has no 'ɵcmp' field`);\n        }\n        // TODO: Don't cast as `InjectionToken<boolean>`, proper type is boolean[]\n        const noNgZone = this.inject(ComponentFixtureNoNgZone, false);\n        // TODO: Don't cast as `InjectionToken<boolean>`, proper type is boolean[]\n        const autoDetect = this.inject(ComponentFixtureAutoDetect, false);\n        const ngZone = noNgZone ? null : this.inject(NgZone, null);\n        const componentFactory = new ɵRender3ComponentFactory(componentDef);\n        const initComponent = () => {\n            const componentRef = componentFactory.create(Injector.NULL, [], `#${rootElId}`, this.testModuleRef);\n            return new ComponentFixture(componentRef, ngZone, autoDetect);\n        };\n        const fixture = ngZone ? ngZone.run(initComponent) : initComponent();\n        this._activeFixtures.push(fixture);\n        return fixture;\n    }\n    /**\n     * @internal strip this from published d.ts files due to\n     * https://github.com/microsoft/TypeScript/issues/36216\n     */\n    get compiler() {\n        if (this._compiler === null) {\n            throw new Error(`Need to call TestBed.initTestEnvironment() first`);\n        }\n        return this._compiler;\n    }\n    /**\n     * @internal strip this from published d.ts files due to\n     * https://github.com/microsoft/TypeScript/issues/36216\n     */\n    get testModuleRef() {\n        if (this._testModuleRef === null) {\n            this._testModuleRef = this.compiler.finalize();\n        }\n        return this._testModuleRef;\n    }\n    assertNotInstantiated(methodName, methodDescription) {\n        if (this._testModuleRef !== null) {\n            throw new Error(`Cannot ${methodDescription} when the test module has already been instantiated. ` +\n                `Make sure you are not using \\`inject\\` before \\`${methodName}\\`.`);\n        }\n    }\n    /**\n     * Check whether the module scoping queue should be flushed, and flush it if needed.\n     *\n     * When the TestBed is reset, it clears the JIT module compilation queue, cancelling any\n     * in-progress module compilation. This creates a potential hazard - the very first time the\n     * TestBed is initialized (or if it's reset without being initialized), there may be pending\n     * compilations of modules declared in global scope. These compilations should be finished.\n     *\n     * To ensure that globally declared modules have their components scoped properly, this function\n     * is called whenever TestBed is initialized or reset. The _first_ time that this happens, prior\n     * to any other operations, the scoping queue is flushed.\n     */\n    checkGlobalCompilationFinished() {\n        // Checking _testNgModuleRef is null should not be necessary, but is left in as an additional\n        // guard that compilations queued in tests (after instantiation) are never flushed accidentally.\n        if (!this._globalCompilationChecked && this._testModuleRef === null) {\n            ɵflushModuleScopingQueueAsMuchAsPossible();\n        }\n        this._globalCompilationChecked = true;\n    }\n    destroyActiveFixtures() {\n        let errorCount = 0;\n        this._activeFixtures.forEach((fixture) => {\n            try {\n                fixture.destroy();\n            }\n            catch (e) {\n                errorCount++;\n                console.error('Error during cleanup of component', {\n                    component: fixture.componentInstance,\n                    stacktrace: e,\n                });\n            }\n        });\n        this._activeFixtures = [];\n        if (errorCount > 0 && this.shouldRethrowTeardownErrors()) {\n            throw Error(`${errorCount} ${(errorCount === 1 ? 'component' : 'components')} ` +\n                `threw errors during cleanup`);\n        }\n    }\n    shouldRethrowTeardownErrors() {\n        var _a, _b;\n        const instanceOptions = this._instanceTeardownOptions;\n        const environmentOptions = TestBedRender3._environmentTeardownOptions;\n        // If the new teardown behavior hasn't been configured, preserve the old behavior.\n        if (!instanceOptions && !environmentOptions) {\n            return false;\n        }\n        // Otherwise use the configured behavior or default to rethrowing.\n        return (_b = (_a = instanceOptions === null || instanceOptions === void 0 ? void 0 : instanceOptions.rethrowErrors) !== null && _a !== void 0 ? _a : environmentOptions === null || environmentOptions === void 0 ? void 0 : environmentOptions.rethrowErrors) !== null && _b !== void 0 ? _b : true;\n    }\n    shouldTearDownTestingModule() {\n        var _a, _b, _c, _d;\n        return (_d = (_b = (_a = this._instanceTeardownOptions) === null || _a === void 0 ? void 0 : _a.destroyAfterEach) !== null && _b !== void 0 ? _b : (_c = TestBedRender3._environmentTeardownOptions) === null || _c === void 0 ? void 0 : _c.destroyAfterEach) !== null && _d !== void 0 ? _d : TEARDOWN_TESTING_MODULE_ON_DESTROY_DEFAULT;\n    }\n    tearDownTestingModule() {\n        var _a;\n        // If the module ref has already been destroyed, we won't be able to get a test renderer.\n        if (this._testModuleRef === null) {\n            return;\n        }\n        // Resolve the renderer ahead of time, because we want to remove the root elements as the very\n        // last step, but the injector will be destroyed as a part of the module ref destruction.\n        const testRenderer = this.inject(TestComponentRenderer);\n        try {\n            this._testModuleRef.destroy();\n        }\n        catch (e) {\n            if (this.shouldRethrowTeardownErrors()) {\n                throw e;\n            }\n            else {\n                console.error('Error during cleanup of a testing module', {\n                    component: this._testModuleRef.instance,\n                    stacktrace: e,\n                });\n            }\n        }\n        finally {\n            (_a = testRenderer.removeAllRootElements) === null || _a === void 0 ? void 0 : _a.call(testRenderer);\n        }\n    }\n}\nlet testBed;\nfunction _getTestBedRender3() {\n    return testBed = testBed || new TestBedRender3();\n}\n\n/**\n * @license\n * Copyright Google LLC All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.io/license\n */\nfunction unimplemented() {\n    throw Error('unimplemented');\n}\n/**\n * Special interface to the compiler only used by testing\n *\n * @publicApi\n */\nclass TestingCompiler extends Compiler {\n    get injector() {\n        throw unimplemented();\n    }\n    overrideModule(module, overrides) {\n        throw unimplemented();\n    }\n    overrideDirective(directive, overrides) {\n        throw unimplemented();\n    }\n    overrideComponent(component, overrides) {\n        throw unimplemented();\n    }\n    overridePipe(directive, overrides) {\n        throw unimplemented();\n    }\n    /**\n     * Allows to pass the compile summary from AOT compilation to the JIT compiler,\n     * so that it can use the code generated by AOT.\n     */\n    loadAotSummaries(summaries) {\n        throw unimplemented();\n    }\n    /**\n     * Gets the component factory for the given component.\n     * This assumes that the component has been compiled before calling this call using\n     * `compileModuleAndAllComponents*`.\n     */\n    getComponentFactory(component) {\n        throw unimplemented();\n    }\n    /**\n     * Returns the component type that is stored in the given error.\n     * This can be used for errors created by compileModule...\n     */\n    getComponentFromError(error) {\n        throw unimplemented();\n    }\n}\nTestingCompiler.ɵfac = /*@__PURE__*/ function () { let ɵTestingCompiler_BaseFactory; return function TestingCompiler_Factory(t) { return (ɵTestingCompiler_BaseFactory || (ɵTestingCompiler_BaseFactory = ɵngcc0.ɵɵgetInheritedFactory(TestingCompiler)))(t || TestingCompiler); }; }();\nTestingCompiler.ɵprov = /*@__PURE__*/ ɵngcc0.ɵɵdefineInjectable({ token: TestingCompiler, factory: TestingCompiler.ɵfac });\n(function () { (typeof ngDevMode === \"undefined\" || ngDevMode) && ɵngcc0.ɵsetClassMetadata(TestingCompiler, [{\n        type: Injectable\n    }], null, null); })();\n/**\n * A factory for creating a Compiler\n *\n * @publicApi\n */\nclass TestingCompilerFactory {\n}\n\n/**\n * @license\n * Copyright Google LLC All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.io/license\n */\nlet _nextRootElementId$1 = 0;\n/**\n * @description\n * Configures and initializes environment for unit testing and provides methods for\n * creating components and services in unit tests.\n *\n * `TestBed` is the primary api for writing unit tests for Angular applications and libraries.\n *\n * Note: Use `TestBed` in tests. It will be set to either `TestBedViewEngine` or `TestBedRender3`\n * according to the compiler used.\n */\nclass TestBedViewEngine {\n    constructor() {\n        this._instantiated = false;\n        this._compiler = null;\n        this._moduleRef = null;\n        this._moduleFactory = null;\n        this._pendingModuleFactory = null;\n        this._compilerOptions = [];\n        this._moduleOverrides = [];\n        this._componentOverrides = [];\n        this._directiveOverrides = [];\n        this._pipeOverrides = [];\n        this._providers = [];\n        this._declarations = [];\n        this._imports = [];\n        this._schemas = [];\n        this._activeFixtures = [];\n        this._testEnvAotSummaries = () => [];\n        this._aotSummaries = [];\n        this._templateOverrides = [];\n        this._isRoot = true;\n        this._rootProviderOverrides = [];\n        this.platform = null;\n        this.ngModule = null;\n    }\n    /**\n     * Initialize the environment for testing with a compiler factory, a PlatformRef, and an\n     * angular module. These are common to every test in the suite.\n     *\n     * This may only be called once, to set up the common providers for the current test\n     * suite on the current platform. If you absolutely need to change the providers,\n     * first use `resetTestEnvironment`.\n     *\n     * Test modules and platforms for individual platforms are available from\n     * '@angular/<platform_name>/testing'.\n     */\n    static initTestEnvironment(ngModule, platform, summariesOrOptions) {\n        const testBed = _getTestBedViewEngine();\n        testBed.initTestEnvironment(ngModule, platform, summariesOrOptions);\n        return testBed;\n    }\n    /**\n     * Reset the providers for the test injector.\n     */\n    static resetTestEnvironment() {\n        _getTestBedViewEngine().resetTestEnvironment();\n    }\n    static resetTestingModule() {\n        _getTestBedViewEngine().resetTestingModule();\n        return TestBedViewEngine;\n    }\n    /**\n     * Allows overriding default compiler providers and settings\n     * which are defined in test_injector.js\n     */\n    static configureCompiler(config) {\n        _getTestBedViewEngine().configureCompiler(config);\n        return TestBedViewEngine;\n    }\n    /**\n     * Allows overriding default providers, directives, pipes, modules of the test injector,\n     * which are defined in test_injector.js\n     */\n    static configureTestingModule(moduleDef) {\n        _getTestBedViewEngine().configureTestingModule(moduleDef);\n        return TestBedViewEngine;\n    }\n    /**\n     * Compile components with a `templateUrl` for the test's NgModule.\n     * It is necessary to call this function\n     * as fetching urls is asynchronous.\n     */\n    static compileComponents() {\n        return getTestBed().compileComponents();\n    }\n    static overrideModule(ngModule, override) {\n        _getTestBedViewEngine().overrideModule(ngModule, override);\n        return TestBedViewEngine;\n    }\n    static overrideComponent(component, override) {\n        _getTestBedViewEngine().overrideComponent(component, override);\n        return TestBedViewEngine;\n    }\n    static overrideDirective(directive, override) {\n        _getTestBedViewEngine().overrideDirective(directive, override);\n        return TestBedViewEngine;\n    }\n    static overridePipe(pipe, override) {\n        _getTestBedViewEngine().overridePipe(pipe, override);\n        return TestBedViewEngine;\n    }\n    static overrideTemplate(component, template) {\n        _getTestBedViewEngine().overrideComponent(component, { set: { template, templateUrl: null } });\n        return TestBedViewEngine;\n    }\n    /**\n     * Overrides the template of the given component, compiling the template\n     * in the context of the TestingModule.\n     *\n     * Note: This works for JIT and AOTed components as well.\n     */\n    static overrideTemplateUsingTestingModule(component, template) {\n        _getTestBedViewEngine().overrideTemplateUsingTestingModule(component, template);\n        return TestBedViewEngine;\n    }\n    static overrideProvider(token, provider) {\n        _getTestBedViewEngine().overrideProvider(token, provider);\n        return TestBedViewEngine;\n    }\n    static inject(token, notFoundValue, flags) {\n        return _getTestBedViewEngine().inject(token, notFoundValue, flags);\n    }\n    /** @deprecated from v9.0.0 use TestBed.inject */\n    static get(token, notFoundValue = Injector.THROW_IF_NOT_FOUND, flags = InjectFlags.Default) {\n        return _getTestBedViewEngine().inject(token, notFoundValue, flags);\n    }\n    static createComponent(component) {\n        return _getTestBedViewEngine().createComponent(component);\n    }\n    static shouldTearDownTestingModule() {\n        return _getTestBedViewEngine().shouldTearDownTestingModule();\n    }\n    static tearDownTestingModule() {\n        _getTestBedViewEngine().tearDownTestingModule();\n    }\n    /**\n     * Initialize the environment for testing with a compiler factory, a PlatformRef, and an\n     * angular module. These are common to every test in the suite.\n     *\n     * This may only be called once, to set up the common providers for the current test\n     * suite on the current platform. If you absolutely need to change the providers,\n     * first use `resetTestEnvironment`.\n     *\n     * Test modules and platforms for individual platforms are available from\n     * '@angular/<platform_name>/testing'.\n     */\n    initTestEnvironment(ngModule, platform, summariesOrOptions) {\n        if (this.platform || this.ngModule) {\n            throw new Error('Cannot set base providers because it has already been called');\n        }\n        this.platform = platform;\n        this.ngModule = ngModule;\n        if (typeof summariesOrOptions === 'function') {\n            this._testEnvAotSummaries = summariesOrOptions;\n            TestBedViewEngine._environmentTeardownOptions = undefined;\n        }\n        else {\n            this._testEnvAotSummaries = (summariesOrOptions === null || summariesOrOptions === void 0 ? void 0 : summariesOrOptions.aotSummaries) || (() => []);\n            TestBedViewEngine._environmentTeardownOptions = summariesOrOptions === null || summariesOrOptions === void 0 ? void 0 : summariesOrOptions.teardown;\n        }\n    }\n    /**\n     * Reset the providers for the test injector.\n     */\n    resetTestEnvironment() {\n        this.resetTestingModule();\n        this.platform = null;\n        this.ngModule = null;\n        this._testEnvAotSummaries = () => [];\n        TestBedViewEngine._environmentTeardownOptions = undefined;\n    }\n    resetTestingModule() {\n        ɵclearOverrides();\n        this._aotSummaries = [];\n        this._templateOverrides = [];\n        this._compiler = null;\n        this._moduleOverrides = [];\n        this._componentOverrides = [];\n        this._directiveOverrides = [];\n        this._pipeOverrides = [];\n        this._isRoot = true;\n        this._rootProviderOverrides = [];\n        this._moduleFactory = null;\n        this._pendingModuleFactory = null;\n        this._compilerOptions = [];\n        this._providers = [];\n        this._declarations = [];\n        this._imports = [];\n        this._schemas = [];\n        // We have to chain a couple of try/finally blocks, because each step can\n        // throw errors and we don't want it to interrupt the next step and we also\n        // want an error to be thrown at the end.\n        try {\n            this.destroyActiveFixtures();\n        }\n        finally {\n            try {\n                if (this.shouldTearDownTestingModule()) {\n                    this.tearDownTestingModule();\n                }\n            }\n            finally {\n                this._moduleRef = null;\n                this._instanceTeardownOptions = undefined;\n                this._instantiated = false;\n            }\n        }\n    }\n    configureCompiler(config) {\n        this._assertNotInstantiated('TestBed.configureCompiler', 'configure the compiler');\n        this._compilerOptions.push(config);\n    }\n    configureTestingModule(moduleDef) {\n        this._assertNotInstantiated('TestBed.configureTestingModule', 'configure the test module');\n        if (moduleDef.providers) {\n            this._providers.push(...moduleDef.providers);\n        }\n        if (moduleDef.declarations) {\n            this._declarations.push(...moduleDef.declarations);\n        }\n        if (moduleDef.imports) {\n            this._imports.push(...moduleDef.imports);\n        }\n        if (moduleDef.schemas) {\n            this._schemas.push(...moduleDef.schemas);\n        }\n        if (moduleDef.aotSummaries) {\n            this._aotSummaries.push(moduleDef.aotSummaries);\n        }\n        // Always re-assign the teardown options, even if they're undefined.\n        // This ensures that we don't carry the options between tests.\n        this._instanceTeardownOptions = moduleDef.teardown;\n    }\n    compileComponents() {\n        if (this._moduleFactory || this._instantiated) {\n            return Promise.resolve(null);\n        }\n        const moduleType = this._createCompilerAndModule();\n        this._pendingModuleFactory = moduleType;\n        return this._compiler.compileModuleAndAllComponentsAsync(moduleType).then(result => {\n            // If the module mismatches by the time the promise resolves, it means that the module has\n            // already been destroyed and a new compilation has started. If that's the case, avoid\n            // overwriting the module factory, because it can cause downstream errors.\n            if (this._pendingModuleFactory === moduleType) {\n                this._moduleFactory = result.ngModuleFactory;\n                this._pendingModuleFactory = null;\n            }\n        });\n    }\n    _initIfNeeded() {\n        if (this._instantiated) {\n            return;\n        }\n        if (!this._moduleFactory) {\n            try {\n                const moduleType = this._createCompilerAndModule();\n                this._moduleFactory =\n                    this._compiler.compileModuleAndAllComponentsSync(moduleType).ngModuleFactory;\n            }\n            catch (e) {\n                const errorCompType = this._compiler.getComponentFromError(e);\n                if (errorCompType) {\n                    throw new Error(`This test module uses the component ${ɵstringify(errorCompType)} which is using a \"templateUrl\" or \"styleUrls\", but they were never compiled. ` +\n                        `Please call \"TestBed.compileComponents\" before your test.`);\n                }\n                else {\n                    throw e;\n                }\n            }\n        }\n        for (const { component, templateOf } of this._templateOverrides) {\n            const compFactory = this._compiler.getComponentFactory(templateOf);\n            ɵoverrideComponentView(component, compFactory);\n        }\n        const ngZone = new NgZone({ enableLongStackTrace: true, shouldCoalesceEventChangeDetection: false });\n        const providers = [{ provide: NgZone, useValue: ngZone }];\n        const ngZoneInjector = Injector.create({\n            providers: providers,\n            parent: this.platform.injector,\n            name: this._moduleFactory.moduleType.name\n        });\n        this._moduleRef = this._moduleFactory.create(ngZoneInjector);\n        // ApplicationInitStatus.runInitializers() is marked @internal to core. So casting to any\n        // before accessing it.\n        this._moduleRef.injector.get(ApplicationInitStatus).runInitializers();\n        this._instantiated = true;\n    }\n    _createCompilerAndModule() {\n        const providers = this._providers.concat([{ provide: TestBed, useValue: this }]);\n        const declarations = [...this._declarations, ...this._templateOverrides.map(entry => entry.templateOf)];\n        const rootScopeImports = [];\n        const rootProviderOverrides = this._rootProviderOverrides;\n        if (this._isRoot) {\n            class RootScopeModule {\n            }\n            RootScopeModule.decorators = [\n                { type: NgModule, args: [{\n                            providers: [\n                                ...rootProviderOverrides,\n                            ],\n                            jit: true,\n                        },] }\n            ];\n            rootScopeImports.push(RootScopeModule);\n        }\n        providers.push({ provide: ɵINJECTOR_SCOPE, useValue: this._isRoot ? 'root' : null });\n        const imports = [rootScopeImports, this.ngModule, this._imports];\n        const schemas = this._schemas;\n        class DynamicTestModule {\n        }\n        DynamicTestModule.decorators = [\n            { type: NgModule, args: [{ providers, declarations, imports, schemas, jit: true },] }\n        ];\n        const compilerFactory = this.platform.injector.get(TestingCompilerFactory);\n        this._compiler = compilerFactory.createTestingCompiler(this._compilerOptions);\n        for (const summary of [this._testEnvAotSummaries, ...this._aotSummaries]) {\n            this._compiler.loadAotSummaries(summary);\n        }\n        this._moduleOverrides.forEach((entry) => this._compiler.overrideModule(entry[0], entry[1]));\n        this._componentOverrides.forEach((entry) => this._compiler.overrideComponent(entry[0], entry[1]));\n        this._directiveOverrides.forEach((entry) => this._compiler.overrideDirective(entry[0], entry[1]));\n        this._pipeOverrides.forEach((entry) => this._compiler.overridePipe(entry[0], entry[1]));\n        return DynamicTestModule;\n    }\n    _assertNotInstantiated(methodName, methodDescription) {\n        if (this._instantiated) {\n            throw new Error(`Cannot ${methodDescription} when the test module has already been instantiated. ` +\n                `Make sure you are not using \\`inject\\` before \\`${methodName}\\`.`);\n        }\n    }\n    inject(token, notFoundValue, flags) {\n        this._initIfNeeded();\n        if (token === TestBed) {\n            return this;\n        }\n        // Tests can inject things from the ng module and from the compiler,\n        // but the ng module can't inject things from the compiler and vice versa.\n        const UNDEFINED = {};\n        const result = this._moduleRef.injector.get(token, UNDEFINED, flags);\n        return result === UNDEFINED ? this._compiler.injector.get(token, notFoundValue, flags) :\n            result;\n    }\n    /** @deprecated from v9.0.0 use TestBed.inject */\n    get(token, notFoundValue = Injector.THROW_IF_NOT_FOUND, flags = InjectFlags.Default) {\n        return this.inject(token, notFoundValue, flags);\n    }\n    execute(tokens, fn, context) {\n        this._initIfNeeded();\n        const params = tokens.map(t => this.inject(t));\n        return fn.apply(context, params);\n    }\n    overrideModule(ngModule, override) {\n        this._assertNotInstantiated('overrideModule', 'override module metadata');\n        this._moduleOverrides.push([ngModule, override]);\n    }\n    overrideComponent(component, override) {\n        this._assertNotInstantiated('overrideComponent', 'override component metadata');\n        this._componentOverrides.push([component, override]);\n    }\n    overrideDirective(directive, override) {\n        this._assertNotInstantiated('overrideDirective', 'override directive metadata');\n        this._directiveOverrides.push([directive, override]);\n    }\n    overridePipe(pipe, override) {\n        this._assertNotInstantiated('overridePipe', 'override pipe metadata');\n        this._pipeOverrides.push([pipe, override]);\n    }\n    overrideProvider(token, provider) {\n        this._assertNotInstantiated('overrideProvider', 'override provider');\n        this.overrideProviderImpl(token, provider);\n    }\n    overrideProviderImpl(token, provider, deprecated = false) {\n        let def = null;\n        if (typeof token !== 'string' && (def = ɵgetInjectableDef(token)) && def.providedIn === 'root') {\n            if (provider.useFactory) {\n                this._rootProviderOverrides.push({ provide: token, useFactory: provider.useFactory, deps: provider.deps || [] });\n            }\n            else {\n                this._rootProviderOverrides.push({ provide: token, useValue: provider.useValue });\n            }\n        }\n        let flags = 0;\n        let value;\n        if (provider.useFactory) {\n            flags |= 1024 /* TypeFactoryProvider */;\n            value = provider.useFactory;\n        }\n        else {\n            flags |= 256 /* TypeValueProvider */;\n            value = provider.useValue;\n        }\n        const deps = (provider.deps || []).map((dep) => {\n            let depFlags = 0 /* None */;\n            let depToken;\n            if (Array.isArray(dep)) {\n                dep.forEach((entry) => {\n                    if (entry instanceof Optional) {\n                        depFlags |= 2 /* Optional */;\n                    }\n                    else if (entry instanceof SkipSelf) {\n                        depFlags |= 1 /* SkipSelf */;\n                    }\n                    else {\n                        depToken = entry;\n                    }\n                });\n            }\n            else {\n                depToken = dep;\n            }\n            return [depFlags, depToken];\n        });\n        ɵoverrideProvider({ token, flags, deps, value, deprecatedBehavior: deprecated });\n    }\n    overrideTemplateUsingTestingModule(component, template) {\n        this._assertNotInstantiated('overrideTemplateUsingTestingModule', 'override template');\n        class OverrideComponent {\n        }\n        OverrideComponent.decorators = [\n            { type: Component, args: [{ selector: 'empty', template, jit: true },] }\n        ];\n        this._templateOverrides.push({ component, templateOf: OverrideComponent });\n    }\n    createComponent(component) {\n        this._initIfNeeded();\n        const componentFactory = this._compiler.getComponentFactory(component);\n        if (!componentFactory) {\n            throw new Error(`Cannot create the component ${ɵstringify(component)} as it was not imported into the testing module!`);\n        }\n        // TODO: Don't cast as `InjectionToken<boolean>`, declared type is boolean[]\n        const noNgZone = this.inject(ComponentFixtureNoNgZone, false);\n        // TODO: Don't cast as `InjectionToken<boolean>`, declared type is boolean[]\n        const autoDetect = this.inject(ComponentFixtureAutoDetect, false);\n        const ngZone = noNgZone ? null : this.inject(NgZone, null);\n        const testComponentRenderer = this.inject(TestComponentRenderer);\n        const rootElId = `root${_nextRootElementId$1++}`;\n        testComponentRenderer.insertRootElement(rootElId);\n        const initComponent = () => {\n            const componentRef = componentFactory.create(Injector.NULL, [], `#${rootElId}`, this._moduleRef);\n            return new ComponentFixture(componentRef, ngZone, autoDetect);\n        };\n        const fixture = !ngZone ? initComponent() : ngZone.run(initComponent);\n        this._activeFixtures.push(fixture);\n        return fixture;\n    }\n    destroyActiveFixtures() {\n        let errorCount = 0;\n        this._activeFixtures.forEach((fixture) => {\n            try {\n                fixture.destroy();\n            }\n            catch (e) {\n                errorCount++;\n                console.error('Error during cleanup of component', {\n                    component: fixture.componentInstance,\n                    stacktrace: e,\n                });\n            }\n        });\n        this._activeFixtures = [];\n        if (errorCount > 0 && this.shouldRethrowTeardownErrors()) {\n            throw Error(`${errorCount} ${(errorCount === 1 ? 'component' : 'components')} ` +\n                `threw errors during cleanup`);\n        }\n    }\n    shouldRethrowTeardownErrors() {\n        var _a, _b;\n        const instanceOptions = this._instanceTeardownOptions;\n        const environmentOptions = TestBedViewEngine._environmentTeardownOptions;\n        // If the new teardown behavior hasn't been configured, preserve the old behavior.\n        if (!instanceOptions && !environmentOptions) {\n            return false;\n        }\n        // Otherwise use the configured behavior or default to rethrowing.\n        return (_b = (_a = instanceOptions === null || instanceOptions === void 0 ? void 0 : instanceOptions.rethrowErrors) !== null && _a !== void 0 ? _a : environmentOptions === null || environmentOptions === void 0 ? void 0 : environmentOptions.rethrowErrors) !== null && _b !== void 0 ? _b : true;\n    }\n    shouldTearDownTestingModule() {\n        var _a, _b, _c, _d;\n        return (_d = (_b = (_a = this._instanceTeardownOptions) === null || _a === void 0 ? void 0 : _a.destroyAfterEach) !== null && _b !== void 0 ? _b : (_c = TestBedViewEngine._environmentTeardownOptions) === null || _c === void 0 ? void 0 : _c.destroyAfterEach) !== null && _d !== void 0 ? _d : TEARDOWN_TESTING_MODULE_ON_DESTROY_DEFAULT;\n    }\n    tearDownTestingModule() {\n        var _a, _b, _c, _d, _e;\n        // If the module ref has already been destroyed, we won't be able to get a test renderer.\n        if (this._moduleRef === null) {\n            return;\n        }\n        // Resolve the renderer ahead of time, because we want to remove the root elements as the very\n        // last step, but the injector will be destroyed as a part of the module ref destruction.\n        const testRenderer = this.inject(TestComponentRenderer);\n        try {\n            this._moduleRef.destroy();\n        }\n        catch (e) {\n            if ((_d = (_b = (_a = this._instanceTeardownOptions) === null || _a === void 0 ? void 0 : _a.rethrowErrors) !== null && _b !== void 0 ? _b : (_c = TestBedViewEngine._environmentTeardownOptions) === null || _c === void 0 ? void 0 : _c.rethrowErrors) !== null && _d !== void 0 ? _d : true) {\n                throw e;\n            }\n            else {\n                console.error('Error during cleanup of a testing module', {\n                    component: this._moduleRef.instance,\n                    stacktrace: e,\n                });\n            }\n        }\n        finally {\n            (_e = testRenderer === null || testRenderer === void 0 ? void 0 : testRenderer.removeAllRootElements) === null || _e === void 0 ? void 0 : _e.call(testRenderer);\n        }\n    }\n}\n/**\n * @description\n * Configures and initializes environment for unit testing and provides methods for\n * creating components and services in unit tests.\n *\n * `TestBed` is the primary api for writing unit tests for Angular applications and libraries.\n *\n * Note: Use `TestBed` in tests. It will be set to either `TestBedViewEngine` or `TestBedRender3`\n * according to the compiler used.\n *\n * @publicApi\n */\nconst TestBed = ɵivyEnabled ? TestBedRender3 : TestBedViewEngine;\n/**\n * Returns a singleton of the applicable `TestBed`.\n *\n * It will be either an instance of `TestBedViewEngine` or `TestBedRender3`.\n *\n * @publicApi\n */\nconst getTestBed = ɵivyEnabled ? _getTestBedRender3 : _getTestBedViewEngine;\nlet testBed$1;\nfunction _getTestBedViewEngine() {\n    return testBed$1 = testBed$1 || new TestBedViewEngine();\n}\n/**\n * Allows injecting dependencies in `beforeEach()` and `it()`.\n *\n * Example:\n *\n * ```\n * beforeEach(inject([Dependency, AClass], (dep, object) => {\n *   // some code that uses `dep` and `object`\n *   // ...\n * }));\n *\n * it('...', inject([AClass], (object) => {\n *   object.doSomething();\n *   expect(...);\n * })\n * ```\n *\n * @publicApi\n */\nfunction inject(tokens, fn) {\n    const testBed = getTestBed();\n    // Not using an arrow function to preserve context passed from call site\n    return function () {\n        return testBed.execute(tokens, fn, this);\n    };\n}\n/**\n * @publicApi\n */\nclass InjectSetupWrapper {\n    constructor(_moduleDef) {\n        this._moduleDef = _moduleDef;\n    }\n    _addModule() {\n        const moduleDef = this._moduleDef();\n        if (moduleDef) {\n            getTestBed().configureTestingModule(moduleDef);\n        }\n    }\n    inject(tokens, fn) {\n        const self = this;\n        // Not using an arrow function to preserve context passed from call site\n        return function () {\n            self._addModule();\n            return inject(tokens, fn).call(this);\n        };\n    }\n}\nfunction withModule(moduleDef, fn) {\n    if (fn) {\n        // Not using an arrow function to preserve context passed from call site\n        return function () {\n            const testBed = getTestBed();\n            if (moduleDef) {\n                testBed.configureTestingModule(moduleDef);\n            }\n            return fn.apply(this);\n        };\n    }\n    return new InjectSetupWrapper(() => moduleDef);\n}\n\n/**\n * @license\n * Copyright Google LLC All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.io/license\n */\nconst _global = (typeof window === 'undefined' ? global : window);\n// Reset the test providers and the fake async zone before each test.\nif (_global.beforeEach) {\n    _global.beforeEach(getCleanupHook(false));\n}\n// We provide both a `beforeEach` and `afterEach`, because the updated behavior for\n// tearing down the module is supposed to run after the test so that we can associate\n// teardown errors with the correct test.\nif (_global.afterEach) {\n    _global.afterEach(getCleanupHook(true));\n}\nfunction getCleanupHook(expectedTeardownValue) {\n    return () => {\n        if (TestBed.shouldTearDownTestingModule() ===\n            expectedTeardownValue) {\n            TestBed.resetTestingModule();\n            resetFakeAsyncZone();\n        }\n    };\n}\n/**\n * This API should be removed. But doing so seems to break `google3` and so it requires a bit of\n * investigation.\n *\n * A work around is to mark it as `@codeGenApi` for now and investigate later.\n *\n * @codeGenApi\n */\n// TODO(iminar): Remove this code in a safe way.\nconst __core_private_testing_placeholder__ = '';\n\n/**\n * @license\n * Copyright Google LLC All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.io/license\n */\n\n/**\n * @license\n * Copyright Google LLC All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.io/license\n */\n\n/**\n * @license\n * Copyright Google LLC All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.io/license\n */\n\n/**\n * @license\n * Copyright Google LLC All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.io/license\n */\n// This file only reexports content of the `src` folder. Keep it that way.\n\n/**\n * @license\n * Copyright Google LLC All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.io/license\n */\n\n/**\n * Generated bundle index. Do not edit.\n */\n\nexport { ComponentFixture, ComponentFixtureAutoDetect, ComponentFixtureNoNgZone, InjectSetupWrapper, TestBed, TestComponentRenderer, __core_private_testing_placeholder__, async, discardPeriodicTasks, fakeAsync, flush, flushMicrotasks, getTestBed, inject, resetFakeAsyncZone, tick, waitForAsync, withModule, MetadataOverrider as ɵMetadataOverrider, TestingCompiler as ɵTestingCompiler, TestingCompilerFactory as ɵTestingCompilerFactory, TestBedViewEngine as ɵangular_packages_core_testing_testing_a, TestBedRender3 as ɵangular_packages_core_testing_testing_b, _getTestBedRender3 as ɵangular_packages_core_testing_testing_c };\n\n//# sourceMappingURL=testing.js.map"]},"metadata":{},"sourceType":"module"}